{"title":"（四）基础构建模块 —— 《Java并发编程实战》","date":"2019-07-29T10:19:30.000Z","slug":"thread4j-c5-builtin-module","tags":["java","thread"],"categories":["Java多线程"],"updated":"2019-07-29T11:44:54.980Z","content":"<p>多线程程序往往是很难控制的，因为我们要保证每一个对象状态的安全，本篇介绍一些Java中内置的用来构建并发程序的模块，让我们更快更优雅的实现并发程序。</p>\n<h2 id=\"concurrent并发数据结构\"><code>concurrent</code>并发数据结构<a href=\"post/thread4j-c5-builtin-module#concurrent并发数据结构\"></a></h2><p>我们先来看看一个具有同步机制的线程安全的数据结构——<code>Vector</code>。</p>\n<p>先看下JDK官方文档中对它的描述，出自JDK1.8：</p>\n<blockquote>\n<p>Unlike the new collection implementations, {@code Vector} is synchronized.  If a thread-safe implementation is not needed, it is recommended to use.</p>\n<p>不同于一个新的集合实现，Vector是同步的。如果不需要一个线程安全实现（指的应该是你不需要主动实现线程安全），推荐使用它。</p>\n</blockquote>\n<p><code>Vector</code>继承了<code>AbstractList</code>并且使用一个数组来管理元素，它通过为每个方法加上<code>synchronized</code>关键字保证每个操作的同步。</p>\n<p>也就是说它就是一个同步的List，不过我们使用它时要注意的是，它只能保证单个操作的同步，如果你的代码中有对<code>Vector</code>的操作依赖上面几行对<code>Vector</code>操作的结果时，需要自行加锁，假设我们对它做迭代操作：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestVector</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Vector&lt;String&gt; vector = <span class=\"keyword\">new</span> Vector&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;vector.size();i++)&#123;</span><br><span class=\"line\">            System.out.println(vector.get(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如上是一个单线程环境下的代码，不过它在多线程环境下会出现问题，<code>main</code>方法中的循环判断条件依据<code>vector.size()</code>的返回结果，当<code>vector.size()</code>返回后当前线程的锁被释放，这时可能有其他线程在当前线程调用<code>vector.get(i)</code>时抢先获得锁，如果它执行了一些删除操作，我们循环中的代码就可能抛出<code>ArrayIndexOutOfBoundsException</code>。</p>\n<p>解决办法是当进行遍历（或任何其他非原子的操作）时，请自行加锁：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span> (vector)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;vector.size();i++)&#123;</span><br><span class=\"line\">        System.out.println(vector.get(i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果你用迭代器操作，也是会出现异常的，但是不是<code>ArrayIndexOutOfBoundsException</code>，迭代器会在每次迭代时检测整个数组是否被修改，如果被修改则会抛出一个<code>ConcurrentModifactionException</code>。</p>\n<p>所以，只要你想在多线程环境下遍历<code>Vector</code>，不管你用什么办法，你都必须得获得锁，如果<code>Vector</code>是一个非常大的集合，而且遍历时对每一个元素的处理很耗时，这时就会造成阻塞，其他线程被都在外面无法进入，对于高并发的程序来说这是不好的。</p>\n<p><strong>而且要注意，当你输出一个vector时，或者把它连接到字符串中时，也会隐式的进行迭代，因为这时调用了它默认的toString方法</strong></p>\n<p>好了，介绍完<code>Vector</code>的缺点现在我们开始并发容器的主题。。。</p>\n<h3 id=\"ConcurrentHashMap\">ConcurrentHashMap<a href=\"post/thread4j-c5-builtin-module#ConcurrentHashMap\"></a></h3><p>这是一个并发的HashMap，Java的<code>concurrent</code>包中有很多为了实现高并发程序设计的数据结构，它就是其中之一，这些数据结构并不是通过为每一个方法加锁来确保安全性，而是使用更细粒度的锁，保证线程安全性的同时提高并发性能。</p>\n<p>在<code>ConcurrentHashMap</code>中多个线程可以并发访问它，而不是一个线程访问另一个线程就必须等待，因为在高并发情况下容器内的元素在很短时间内会经常的改变，所以一定程度的损失是可以容忍的，在迭代操作中，它能保证遍历当前已有的元素并且尽量把所有的修改操作反映到容器。</p>\n<p>实现高并发性能的代价就是一些在高并发应用中不那么重要的方法被减弱了，例如<code>size()</code>、<code>isEmpty()</code>，因为在高并发环境下容器的内容频繁改变，所以这些方法的返回值在计算时可能已经过期了，不过仔细想想这些方法在高并发应用中我们确实不太常用。</p>\n<p><code>ConcurrentHashMap</code>实现了一些常用的复合操作的原子版，比如“没有则添加”、“相等则移除”等。</p>\n<h3 id=\"CopyOnWriteArrayList\">CopyOnWriteArrayList<a href=\"post/thread4j-c5-builtin-module#CopyOnWriteArrayList\"></a></h3><p>从名字分析，就是在写入时复制的列表，它可以替代同步List。</p>\n<p>如果你自己去看这个类的源码，你就会发现它确实是每次add操作都会把整个数组复制一遍，复制成一个新的数组，这也说明了它不适合做一个元素会经常被改动的容器，因为操作的时间复杂度和空间复杂度都很高，也很耗资源。它适合做一些监听器列表等操作，只需要在初始化时把所有监听器设置进去，当事件发生时，遍历所有的监听器发送事件。</p>\n<h3 id=\"BlockingQueue\">BlockingQueue<a href=\"post/thread4j-c5-builtin-module#BlockingQueue\"></a></h3><p>阻塞队列是一个多线程环境下特别特别特别特别特别特别好用的FIFO队列数据结构，当<code>put</code>时如果队列满就会阻塞，等待何时队列腾出空位再加入，<code>take</code>操作时如果队列为空也会阻塞，等待何时队列中有内容时再弹出。</p>\n<p>反正我看到它的介绍时一下就想到了多线程中经典的生产者消费者模式，不知道你想到没有，哈哈。这个队列让我们可以方便的实现生产者消费者模式，而不用我们自己实现锁，自己操作<code>wait</code>和<code>notify</code>。下面是使用阻塞队列实现生产者消费者的一个示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> BlockingQueue&lt;String&gt; productQueue =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> ArrayBlockingQueue(<span class=\"number\">20</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Worker</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Worker</span><span class=\"params\">(String name)</span></span>&#123;<span class=\"keyword\">super</span>(name);&#125;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">                Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        Thread.sleep(random.nextInt(<span class=\"number\">5</span>)*<span class=\"number\">1000</span>);</span><br><span class=\"line\">                        String product = String.valueOf(System.nanoTime());</span><br><span class=\"line\">                        productQueue.add(product);</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"Worker \"</span>+Thread.currentThread().getName()</span><br><span class=\"line\">                                +<span class=\"string\">\" put \"</span>+product+<span class=\"string\">\" to the queue.\"</span>);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Consumer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Consumer</span><span class=\"params\">(String name)</span></span>&#123;<span class=\"keyword\">super</span>(name);&#125;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">                Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        Thread.sleep(random.nextInt(<span class=\"number\">5</span>)*<span class=\"number\">1000</span>);</span><br><span class=\"line\">                        String product = productQueue.take();</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"Consumer \"</span>+Thread.currentThread().getName()</span><br><span class=\"line\">                                +<span class=\"string\">\" take \"</span>+product+<span class=\"string\">\" from the queue.\"</span>);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Worker(<span class=\"string\">\"W\"</span>+i).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Consumer(<span class=\"string\">\"C\"</span>+i).start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码用了阻塞队列的一个实现<code>ArrayBlockingQueue</code>，它还有一些其他实现，比如按照优先级排序的<code>PriorityBlockingQueue</code>和同步队列<code>SynchronousQueue</code>（不维护空间，直接把产品交给消费者）</p>\n<h3 id=\"双端队列与密取\">双端队列与密取<a href=\"post/thread4j-c5-builtin-module#双端队列与密取\"></a></h3><p>Deque的阻塞实现是<code>BlockingDeque</code>，是JDK6中加入的双端队列数据结构，可以从两端加入或弹出。</p>\n<p>密取模式则是生产者消费者的升级版，传统的生产者消费者模式因为共用一个队列，经常会出现生产者跟不上消费者或消费者跟不上生产者的情况，然后速度比较快的一方会经常阻塞，效率不高。密取模式则各有各的队列，当消费者没有可消费的东西时就偷偷的去其他消费者那取，当生产者队列满时则悄悄的去其他生产者那里生产。</p>\n<p>密取使用双端队列可以更好的减少竞争，密取操作从尾部获取，而正常操作从头部。</p>\n<h3 id=\"同步工具类\">同步工具类<a href=\"post/thread4j-c5-builtin-module#同步工具类\"></a></h3><p>同步工具类即控制多个线程等待执行状态的工具类，所以BlockingQueue也可以作为一个同步工具类，Java中提供了一些线程的同步工具类。</p>\n<p>先介绍一种东西叫闭锁，它像一个大门，当条件未满足时这扇大门关着，一个线程都不能通过，而条件满足时这扇大门敞开，所有线程都可以通过。<br><code>CountDownLatch</code>可以作为一个闭锁，它提供一个计数器，在构造时传入，调用<code>await</code>方法会产生阻塞，只有当计数器为0时阻塞才会结束，调用<code>countDown</code>方法可以使计数器减一。下面是一个用例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestHarness</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">timeTask</span><span class=\"params\">(<span class=\"keyword\">int</span> nThreads,Runnable task)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        CountDownLatch startGate = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</span><br><span class=\"line\">        CountDownLatch endGate = <span class=\"keyword\">new</span> CountDownLatch(nThreads);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;nThreads;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> Thread()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        startGate.await();</span><br><span class=\"line\">                        task.run();</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                        endGate.countDown();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> startTime = System.nanoTime();</span><br><span class=\"line\">        startGate.countDown();</span><br><span class=\"line\">        endGate.await();</span><br><span class=\"line\">        <span class=\"keyword\">long</span> endTime = System.nanoTime();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> endTime - startTime;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Runnable task  = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> timePast = <span class=\"keyword\">new</span> TestHarness().timeTask(<span class=\"number\">1000</span>,task);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"All done , time : \"</span>+timePast);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>未完。。。马上完了。。。明天补上。。。睡觉了。。。</p>\n","next":{"title":"（三）对象的组合 —— 《Java并发编程实战》","slug":"thread4j-c4-obj-fit"},"link":"http://lilpig.site/post/thread4j-c5-builtin-module/","toc":[{"title":"<code>concurrent</code>并发数据结构","id":"concurrent并发数据结构","index":"1","children":[{"title":"ConcurrentHashMap","id":"ConcurrentHashMap","index":"1.1"},{"title":"CopyOnWriteArrayList","id":"CopyOnWriteArrayList","index":"1.2"},{"title":"BlockingQueue","id":"BlockingQueue","index":"1.3"},{"title":"双端队列与密取","id":"双端队列与密取","index":"1.4"},{"title":"同步工具类","id":"同步工具类","index":"1.5"}]}],"reward":true,"copyright":{"author":"LIL PIG","link":"<a href=\"http://lilpig.site/post/thread4j-c5-builtin-module/\" title=\"（四）基础构建模块 —— 《Java并发编程实战》\">http://lilpig.site/post/thread4j-c5-builtin-module/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}