{"title":"（六）线程取消和关闭 —— 《Java并发编程实战》","date":"2019-07-31T09:19:30.000Z","slug":"thread4j-c7-stop","tags":["java","thread"],"categories":["Java多线程"],"updated":"2019-07-31T12:08:48.421Z","content":"<h2 id=\"取消线程的思路\">取消线程的思路<a href=\"post/thread4j-c7-stop#取消线程的思路\"></a></h2><p>在单线程中如果关闭一个任务，我们习惯了直接去调用提供的<code>close</code>、<code>shutdown</code>等诸如此类的关闭方法，比如流操作，但是在多线程中就并非这么简单了，你永远不能直接关闭一个线程（其实可以但你不能这样去做）。因为在多线程编程中，你可能根本不知道子线程此时的任务进度，不知道子线程当前在干什么，如果你贸然的直接关闭子线程，那么子线程很可能会丢失当前的状态，并且任务还没做完就被直接关闭可能会造成一些安全隐患。</p>\n<p>在Java中，早期有个<code>shutdown</code>方法可以直接关闭线程，但是现在它已经废弃了，Java不推荐你这么做，取而代之的是一种基于信号的协商模式，即给子线程发送关闭信号，子线程检测到关闭信号就会安全的暂停当前任务，做一些释放资源的操作，然后结束掉。这是一个设计良好的线程类应该做的事，当然线程类也可以完全忽略这个信号，继续执行，总之，基于协商模式的取消操作会发生什么结果完全取决于线程自己，因为也只有线程自己最清楚自己当前执行的任务。</p>\n<p>造成需要结束线程运行的原因有以下几种：</p>\n<ul>\n<li>用户取消</li>\n<li>发生错误</li>\n<li>某个取消的条件满足</li>\n</ul>\n<p>我们看一个简单的结束线程的例子：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadStop</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> isStop = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!isStop)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"RUNNING\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span></span>&#123;isStop = <span class=\"keyword\">true</span>;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span>  </span>&#123;</span><br><span class=\"line\">        ThreadStop thread = <span class=\"keyword\">new</span> ThreadStop();</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            thread.cancel();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>线程使用一个布尔变量<code>isStop</code>来控制线程的停止，并提供<code>cancel</code>方法让外部停止线程，在调用者线程中（示例中是主线程）先等待了5秒然后调用了<code>cancel</code>,在<code>finally</code>中调用能保证<code>cencel</code>被正常执行，否则该程序将永远不能关闭。因为<code>isStop</code>的控制权被交给了外界，也就是相当于发布到了外界，虽然<code>cencel</code>中的操作是原子的，但不能保证可见性，所以加上<code>volatile</code>。</p>\n<p>上面的代码还是有问题，如果在<code>while</code>循环中调用了阻塞方法，比如该线程是一个生产者，现在产品队列已经满了，而且所有消费者线程已经正常的结束，也就是说永远不会有消费者拿走产品给生产者留下空位，这时将永远阻塞在向产品队列中添加产品这一操作上，无法退出，程序将一直运行。如下面的示例所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NeverStopThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> isStop = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BlockingQueue&lt;String&gt; blockingQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NeverStopThread</span><span class=\"params\">(BlockingQueue&lt;String&gt; blockingQueue)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.blockingQueue = blockingQueue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!isStop)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"Producer putting...\"</span>);</span><br><span class=\"line\">                blockingQueue.put(<span class=\"string\">\"STRING\"</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        isStop = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"User cancel...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span>  </span>&#123;</span><br><span class=\"line\">        BlockingQueue&lt;String&gt; blockingQueue = <span class=\"keyword\">new</span> ArrayBlockingQueue(<span class=\"number\">5</span>);</span><br><span class=\"line\">        NeverStopThread thread = <span class=\"keyword\">new</span> NeverStopThread(blockingQueue);</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            thread.cancel();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个示例将一直运行，不能停止。分析下，我们的问题就是Java提供的API，<code>BlockingQueue</code>不了解我们线程的停止机制，它无法去检测我们的停止标志<code>isStop</code>。所以这时就该用Java提供的停止机制了，这样Java内置的阻塞模块或者其他模块就能检测到我们的停止状态了。</p>\n<h2 id=\"interrupt\">interrupt<a href=\"post/thread4j-c7-stop#interrupt\"></a></h2><p>Thread类提供了几个用于设置停止标志的方法：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">方法名</th>\n<th style=\"text-align:center\">返回值</th>\n<th style=\"text-align:center\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">interrupt</td>\n<td style=\"text-align:center\">void</td>\n<td style=\"text-align:center\">设置停止状态</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">isInterrupted</td>\n<td style=\"text-align:center\">boolean</td>\n<td style=\"text-align:center\">是否处于停止状态</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><em>interrupted</em></td>\n<td style=\"text-align:center\">boolean</td>\n<td style=\"text-align:center\">查看是否处于停止状态，如果是，则恢复状态</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>有了规定的统一的停止信号操作，一些官方提供的阻塞方法就可以检测到线程是否停止了，如果检测到则会取消阻塞，清除中断状态并抛出<code>InterruptedException</code>，这也是为啥我们通常见到的阻塞方法都会抛出<code>InterruptedException</code>。</p>\n<p>我们改写上面的<code>NeverStopThread</code>，让它能够正确的停止而不是一直阻塞在<code>blockingQueue.put</code>方法那。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CanStopThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BlockingQueue&lt;String&gt; blockingQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CanStopThread</span><span class=\"params\">(BlockingQueue&lt;String&gt; blockingQueue)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.blockingQueue = blockingQueue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!Thread.currentThread().isInterrupted())&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"Producer putting...\"</span>);</span><br><span class=\"line\">                blockingQueue.put(<span class=\"string\">\"STRING\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (InterruptedException e)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Thread was interrupted!\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span>  </span>&#123;</span><br><span class=\"line\">        BlockingQueue&lt;String&gt; blockingQueue = <span class=\"keyword\">new</span> ArrayBlockingQueue(<span class=\"number\">5</span>);</span><br><span class=\"line\">        CanStopThread thread = <span class=\"keyword\">new</span> CanStopThread(blockingQueue);</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            thread.interrupt();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>因为使用了官方提供的取消方法，所以<code>blockingQueue.put</code>会正确的检测到主线程设置的停止状态并抛出异常，我们在线程的<code>run</code>方法里捕获它，打印一条消息后退出。还有一种情况是<code>put</code>操作后被终端，<code>while</code>条件不满足，那么我们就自行抛出异常，然后再自己捕获，这样写起来简洁一些。</p>\n<p>我们看下阻塞队列的<code>put</code>操作的代码，分析下它是怎么检测的，<code>put</code>方法使用一个<code>Condition</code>工具类实现阻塞，实现阻塞的主要是<code>await</code>方法，如下所示：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    Node node = addConditionWaiter();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> savedState = fullyRelease(node);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> interruptMode = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class=\"line\">        LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class=\"line\">        interruptMode = REINTERRUPT;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.nextWaiter != <span class=\"keyword\">null</span>) <span class=\"comment\">// clean up if cancelled</span></span><br><span class=\"line\">        unlinkCancelledWaiters();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (interruptMode != <span class=\"number\">0</span>)</span><br><span class=\"line\">        reportInterruptAfterWait(interruptMode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在入口处会判断一次<code>Thread.interrupted</code>，这是那个会清除状态的静态方法，如果返回<code>true</code>证明当前线程已经被取消了，就直接抛出<code>InterruptedException</code>，也就是说当发生阻塞时在入口处就会判断一次是否取消，如果取消立即返回。</p>\n<p>下面的代码虽然看不太懂，从语义上也可以分析出来，主要阻塞功能是依靠那个<code>while</code>循环完成的，每次循环都会调用<code>checkInterruptWhileWaiting</code>，如果方法不返回0就跳出，我们看看这个方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">checkInterruptWhileWaiting</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Thread.interrupted() ?</span><br><span class=\"line\">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class=\"line\">        <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>还是调用了<code>Thread.interrupted</code>，而且返回了类似状态的东西，反正就是只要线程被取消了就不返回0，也就是让<code>await</code>中的主循环退出，也就是说<code>await</code>的阻塞主循环中一直在判断线程的取消状态，如果取消就结束阻塞。最后一个<code>if</code>判断了跳出时的返回值，如果不是0，就是阻塞是因为线程取消结束的话就调用<code>reportInterruptAfterWait</code>，这个方法就是抛出了个<code>InterruptedException</code>异常方便我们在线程中捕获，篇幅问题不放了，感兴趣的自己扒代码。</p>\n<p>尽管我们没有分析其他阻塞方法的代码，但是原理大同小异，我们知道了Java中的阻塞方法当检测到线程被<code>interrupt</code>方法取消时的操作了，就是重置取消状态（设置为未取消）并抛出异常。</p>\n<h2 id=\"响应中断\">响应中断<a href=\"post/thread4j-c7-stop#响应中断\"></a></h2><p>线程和任务一般是分开进行的，可能就像下面的代码一样，用一个<code>doSomething</code>方法去执行任务，尤其当我们用<code>Executor</code>时更能体会到任务和线程的分离，我们一般在线程执行的任务中如果发生中断，有两种响应策略让线程感知到中断并执行退出操作，分情况使用不同的响应策略。假设我们有这样的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HandleInterrupt</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BlockingQueue&lt;String&gt; queue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HandleInterrupt</span><span class=\"params\">(BlockingQueue&lt;String&gt; queue)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.queue = queue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread()&#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!Thread.currentThread().isInterrupted())&#123;</span><br><span class=\"line\">                    doSomething();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//退出操作</span></span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"Exit...\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>假设<code>doSomething</code>中会执行阻塞队列中的阻塞方法，那么在<code>doSomething</code>中当catch到阻塞方法的<code>InterruptedException</code>时有两种解决办法，一是直接向上抛出，然后修改我们这个线程的主循环，添加<code>try-catch</code>语句，这样线程就能感应到在执行<code>doSomething</code>中的阻塞方法时被中断了，如果不抛出则<code>while</code>的条件不会检测到线程被中断，因为阻塞方法会重置中断状态，刚刚我们分析过了。</p>\n<p>第一种方法：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    queue.take();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在这种方法中我们直接向上抛出就好了，当然如果你需要记录一些状态，也可以catch住后做一些操作再抛出。然后需要在线程主循环里用<code>try-catch</code>捕获，第二中响应策略则是重置中断状态，就是调用<code>interrupt</code>方法重新中断当前线程，这样线程的<code>while</code>条件就能检测到了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        queue.take();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        Thread.currentThread().interrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然这种方法更适合在<code>Runnable</code>这种接口中规定不允许抛出异常的方法中使用，而且这种方法还可以进行重试操作，貌似灵活性更高。要注意的是如果执行重试操作的话重新中断当前线程操作一定要在最后重试也失败时调用，因为重置完线程已经是中断的了，阻塞操作一开始就会直接返回，详见上面分析阻塞队列检测中断代码的部分。</p>\n<p>如果任务中没有阻塞方法，你也可以自己通过轮询来检测线程状态。</p>\n<p>有些时候你如果是编写任务，你不知道当前任务执行在哪个线程，也不知道该线程对与中断的处理是怎样的，一个设计不好的线程可能完全没有做中断处理，也就是说你调用一万次<code>interrupt</code>它也会固执的继续执行，所以当你不了解线程的中断处理策略时请不要贸然调用它的<code>interrupt</code>方法。</p>\n<h2 id=\"处理不可中断的阻塞\">处理不可中断的阻塞<a href=\"post/thread4j-c7-stop#处理不可中断的阻塞\"></a></h2><p>大部分的阻塞操作都会判断线程状态并结束阻塞状态，但是也有不能检测的阻塞，这会造成线程无法及时的终止，我们来看看在这些不能中断的阻塞中该如何检测中断并结束运行。</p>\n<p>先来看看有哪些不可中断的阻塞：</p>\n<ul>\n<li><strong>Socket I/O</strong><br>  它的输入和输出流因为要经过网络所以会产生阻塞，而且这个阻塞不会检测线程的中断状态，但是通过关闭底层的套接字连接可以使流的<code>read</code>和<code>write</code>方法抛出<code>SocketException</code></li>\n<li><strong>I/O</strong><br>  和SocketIO一样，Java的同步IO依然不会检测中断状态。当中断一个正在<code>InterruptibleChannel</code>上等待的线程时，将抛出<code>ClosedByInterruptExcepiton</code>并关闭链路，当关闭一个<code>InterruptibleChannel</code>时将导致所有在链路操作上阻塞的线程都抛出<code>AsynchronousCloseException</code>，大多数标准Channel都实现了<code>InterruptibleChannel</code></li>\n<li><strong>Selector的异步I/O</strong><br>  如果一个线程在调用<code>Selector.select</code>方法时阻塞了，那么调用<code>close</code>或<code>wakeup</code>方法会使线程抛出<code>ClosedSelectorException</code>并提前返回。</li>\n<li><strong>获取某个锁</strong><br>  如果线程等待某个内置锁而阻塞，造成无法响应中断，因为线程认为它肯定会获得锁，所以将不理会中断请求，但是在<code>Lock</code>类中提供了<code>lockInterruptibly</code>方法，该方法允许在等待一个锁的同时仍能响应中断。</li>\n</ul>\n<p>我们看一个从<code>socket</code>套接字中不断读取数据的线程代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReaderThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Socket socket;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> InputStream in;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReaderThread</span><span class=\"params\">(Socket socket)</span><span class=\"keyword\">throws</span> IOException</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.socket = socket;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.in = socket.getInputStream();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!Thread.currentThread().isInterrupted())&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> count = in.read(buf);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (count&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (count&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"keyword\">new</span> String(buf));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">        ServerSocket serverSocket = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">11111</span>);</span><br><span class=\"line\">        Socket socket = serverSocket.accept();</span><br><span class=\"line\">        ReaderThread readerThread = <span class=\"keyword\">new</span> ReaderThread(socket);</span><br><span class=\"line\">        readerThread.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        <span class=\"comment\">//中断线程</span></span><br><span class=\"line\">        readerThread.interrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们可以看到，<code>read</code>方法虽然会在网络操作中产生阻塞，但是它并未抛出任何异常，也就是说他没有检测当前线程是否停止的能力，就算我们从<code>while</code>中判断线程是否停止也不能及时停止线程，因为<code>while</code>的每次判断要在<code>read</code>操作的阻塞之后才会执行。我们用nc连接并尝试发送消息发现消息被打印到控制台了，这不是我们所期待的，我们希望中断线程后立即停止所有工作。</p>\n<p><code>nc测试操作</code><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  cmder nc localhost 11111</span><br><span class=\"line\">asdf</span><br></pre></td></tr></table></figure></p>\n<p><code>程序打印</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">asdf</span><br></pre></td></tr></table></figure></p>\n<p>我们通过修改ReaderThread的<code>interrupt</code>方法来是修改程序，当<code>interrupt</code>被调用，立即关闭<code>socket</code>，此时<code>read</code>方法会抛出一个未检测异常<code>SocketException</code>，我们再捕获它，结束操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReaderTheadImprove</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Socket socket;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> InputStream in;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReaderTheadImprove</span><span class=\"params\">(Socket socket)</span><span class=\"keyword\">throws</span> IOException</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.socket = socket;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.in = socket.getInputStream();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">interrupt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            in.close();</span><br><span class=\"line\">            socket.close();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (IOException e)&#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>.interrupt();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!Thread.currentThread().isInterrupted())&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> count = in.read(buf);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (count&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (count&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"keyword\">new</span> String(buf));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">        ServerSocket serverSocket = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">11111</span>);</span><br><span class=\"line\">        Socket socket = serverSocket.accept();</span><br><span class=\"line\">        ReaderTheadImprove readerThread = <span class=\"keyword\">new</span> ReaderTheadImprove(socket);</span><br><span class=\"line\">        readerThread.start();</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        readerThread.interrupt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际上，这个代码和上面的也没啥区别，因为我发现<code>in.close</code>和<code>socket.close</code>在<code>read</code>阻塞时也都会产生阻塞。我也没太理解作者的用意。</p>\n<h2 id=\"用newTaskFor封装非标准取消\">用<code>newTaskFor</code>封装非标准取消<a href=\"post/thread4j-c7-stop#用newTaskFor封装非标准取消\"></a></h2><p>我们可以把上面的代码封装成用<code>Executor</code>和<code>Future</code>版本的，并且通过重写<code>future</code>的<code>cancel</code>方法关闭<code>socket</code>，通过重写<code>ThreadPoolExecutor</code>的<code>newTaskFor</code>方法创建<code>CancellableTask</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReaderThreadWithExecutor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CancellableTask</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">T</span>&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">        <span class=\"function\">RunnableFuture&lt;T&gt; <span class=\"title\">newTask</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CancellingExecutor</span> <span class=\"keyword\">extends</span> <span class=\"title\">ThreadPoolExecutor</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CancellingExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize, <span class=\"keyword\">int</span> maximumPoolSize, <span class=\"keyword\">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> &lt;T&gt; <span class=\"function\">RunnableFuture&lt;T&gt; <span class=\"title\">newTaskFor</span><span class=\"params\">(Callable&lt;T&gt; callable)</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (callable <span class=\"keyword\">instanceof</span> CancellableTask)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ((CancellableTask&lt;T&gt;) callable).newTask();</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.newTaskFor(callable);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SocketUsingTask</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">CancellableTask</span>&lt;<span class=\"title\">T</span>&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Socket socket;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">setSocket</span><span class=\"params\">(Socket s)</span></span>&#123;socket = s;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">cancel</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (socket!=<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    socket.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> RunnableFuture&lt;T&gt; <span class=\"title\">newTask</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FutureTask&lt;T&gt;(<span class=\"keyword\">this</span>)&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">cancel</span><span class=\"params\">(<span class=\"keyword\">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        SocketUsingTask.<span class=\"keyword\">this</span>.cancel();</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.cancel(mayInterruptIfRunning);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","next":{"title":"（五）任务执行 —— 《Java并发编程实战》","slug":"thread4j-c6-executor"},"link":"http://lilpig.site/post/thread4j-c7-stop/","toc":[{"title":"取消线程的思路","id":"取消线程的思路","index":"1"},{"title":"interrupt","id":"interrupt","index":"2"},{"title":"响应中断","id":"响应中断","index":"3"},{"title":"处理不可中断的阻塞","id":"处理不可中断的阻塞","index":"4"},{"title":"用<code>newTaskFor</code>封装非标准取消","id":"用newTaskFor封装非标准取消","index":"5"}],"reward":true,"copyright":{"author":"LIL PIG","link":"<a href=\"http://lilpig.site/post/thread4j-c7-stop/\" title=\"（六）线程取消和关闭 —— 《Java并发编程实战》\">http://lilpig.site/post/thread4j-c7-stop/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}