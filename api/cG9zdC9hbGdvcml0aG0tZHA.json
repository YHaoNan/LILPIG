{"title":"动态规划","date":"2020-01-23T05:01:19.000Z","slug":"algorithm-dp","tags":["动态规划","算法"],"categories":["算法"],"updated":"2020-01-23T05:09:20.865Z","content":"<p>动态规划常用于寻找最优解，寻找解的个数等。它适用于处理能被分解成若干子问题的问题，动态规划通过保存每个子问题求解时的结果来解决这类问题，这有点像缓存技术。</p>\n<p>听起来可能有些云里雾里，不过我们借鉴一个quora上的高赞回答来理解它：</p>\n<blockquote>\n<p>Q: 如何给4岁的孩子解释动态规划</p>\n<p>A:</p>\n<h1 id=\"在纸上写-“1-1-1-1-1-1-1-1-”\"><a href=\"#在纸上写-“1-1-1-1-1-1-1-1-”\" class=\"headerlink\" title=\"在纸上写 “1+1+1+1+1+1+1+1=”\"></a>在纸上写 “1+1+1+1+1+1+1+1=”</h1><p>“这等于几啊？”</p>\n<h1 id=\"小朋友掰手指数数中…\"><a href=\"#小朋友掰手指数数中…\" class=\"headerlink\" title=\"小朋友掰手指数数中…\"></a>小朋友掰手指数数中…</h1><p>“等于八!”</p>\n<h1 id=\"再在左边填一个”1-”\"><a href=\"#再在左边填一个”1-”\" class=\"headerlink\" title=\"再在左边填一个”1+”\"></a>再在左边填一个”1+”</h1><p>“现在呢？”</p>\n<h1 id=\"很快\"><a href=\"#很快\" class=\"headerlink\" title=\"很快\"></a>很快</h1><p>“九!”</p>\n<p>“你咋这么快就知道是九了？”</p>\n<p>“因为你只加了一个”</p>\n<p>“所以你不用重新数，因为你已经记住之前是八了，动态规划只是’记住结果以节省时间’的时髦说法”</p>\n</blockquote>\n<p><a href=\"https://www.quora.com/How-should-I-explain-dynamic-programming-to-a-4-year-old\" target=\"_blank\" rel=\"noopener\">原问题链接</a></p>\n<p>虽然不知道为啥提问者要给4岁的孩子讲动态规划，但是这个生动形象的例子足以让我们理解动态规划的核心思想。</p>\n<h2 id=\"斐波那契热身\">斐波那契热身<a href=\"post/algorithm-dp#斐波那契热身\"></a></h2><p>我们先用这个大家都熟知的斐波那契数列来举例。</p>\n<blockquote>\n<p>斐波那契数列即如下这个数列：</p>\n<p>1 1 2 3 5 8 …</p>\n<p>即它的后一个数是前两个数之和</p>\n</blockquote>\n<p>假设我们有一个函数<code>fib(i)</code>用于求解求斐波那契数列的第i个元素（假设i从1开始），那么则有递归式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fib(i) = fib(i-1) + fib(i-2)</span><br></pre></td></tr></table></figure>\n<p>利用递归，我们把它分解成了若干子问题进行求解，再把这些子问题累加，得到最终的解。</p>\n<p>对于递归，一件必须要做的事就是找到出口，也就是结束条件，否则它就会一直递归下去，那么它的条件就是当<code>i==1 or i==2</code>的时候直接返回1，因为这是斐波那契数列的前两个数，不能再找到<code>i-2</code>和<code>i-1</code>了。</p>\n<p>编写代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 递归 不使用动态规划</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fib</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n==<span class=\"number\">1</span> <span class=\"keyword\">or</span> n==<span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fib(n<span class=\"number\">-1</span>) + fib(n<span class=\"number\">-2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">fib(<span class=\"number\">6</span>)</span><br></pre></td></tr></table></figure></p>\n<p>这尼玛不就是递归吗，你丫说这么半天，这就是动态规划？那我打娘胎里就会了！</p>\n<p>诶不要急，这确实只是个递归，它还没用到动态规划。这个递归是有问题的，问题就是它的子问题中有不少重叠的，我们看看fib(5)的执行过程：</p>\n<div class=\"article-img\"><p><img src=\"https://s2.ax1x.com/2020/01/23/1ERhX4.jpg\" alt data-zoomable></p></div>\n<p>fib(5)依赖fib(4)和fib(3)，fib(4)又依赖fib(3)和fib(2)，子问题重叠就是这样子造成的，图中每个被两个箭头指向的节点都是重复的子问题，我们把这棵树展开：</p>\n<div class=\"article-img\"><p><img src=\"https://s2.ax1x.com/2020/01/23/1EW7rQ.jpg\" alt data-zoomable></p></div>\n<p>我有点懒就简单画画，大家应该发现问题了，这会导致某些子问题被计算机重复计算多次，浪费时间，如果计算的是fib(6)，树的规模又要大将近一倍，所以它的时间复杂度是O(2^n)</p>\n<p>造成重叠子问题的原因是我们的算法只知道递归，它并不知道它递归计算的内容之前已经计算过了，不过如果我们使用数组去保存每个计算过的值，那么它就不会造成不必要的递归计算，直接就会取之前的值，那么时间复杂度就从指数级别变成了线性级别的O(n)。这是典型的空间换时间的例子，也就是动态规划的思想，我们编写代码来实现一下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 使用动态规划进行递归调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fib_dynamic</span><span class=\"params\">(cache,n)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n==<span class=\"number\">1</span> <span class=\"keyword\">or</span> n==<span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> cache[n] != <span class=\"number\">-1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cache[n]</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        cache[n] = fib_dynamic(cache,n<span class=\"number\">-1</span>) + fib_dynamic(cache,n<span class=\"number\">-2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cache[n]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fib_wrapper</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> fib_dynamic([<span class=\"number\">-1</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>,n+<span class=\"number\">1</span>)],n)</span><br><span class=\"line\"></span><br><span class=\"line\">fib_wrapper(<span class=\"number\">6</span>)</span><br></pre></td></tr></table></figure>\n<p>上面两种都是采用递归进行自顶向下的计算，动态规划还有一种计算方式，也是最常见的计算方式，就是自底向上的循环计算方式，这种计算方式还可以节省掉不必要的函数调用的开销，也避免了最大递归深度异常，并且非常简洁：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fib_not_res</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    cache = [<span class=\"number\">-1</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>,n+<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"comment\"># 确定初始条件</span></span><br><span class=\"line\">    cache[<span class=\"number\">0</span>],cache[<span class=\"number\">1</span>] = <span class=\"number\">1</span> ,<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>,n+<span class=\"number\">1</span>):</span><br><span class=\"line\">        cache[i] = cache[i<span class=\"number\">-1</span>] + cache[i<span class=\"number\">-2</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cache[len(cache) - <span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<h2 id=\"动态规划问题的求解套路\">动态规划问题的求解套路<a href=\"post/algorithm-dp#动态规划问题的求解套路\"></a></h2><ol>\n<li>确定子问题<br> 确定该题中的问题可以分解成哪些子问题</li>\n<li>写出递归方程<br> 根据第一部写出递归方程</li>\n<li>确定初始条件和边界<br> 动态规划的题目中一般情况下都需要确定初始条件，即一个或几个（有限个）预先定义好的值，然后根据这些值计算其他的值，如斐波那契数列中的前两个。边界即停止条件。</li>\n<li>确定计算顺序<br> 一般题目的计算顺序是从前向后，比如斐波那契数列。具体情况还要看题目，如果后面计算当前值时需要依赖的值都是前面已经计算好的，那就是从前向后。后面的练习题目中有一个非从前向后的顺序。</li>\n</ol>\n<h2 id=\"我该怎么才能得到最多的钱？\">我该怎么才能得到最多的钱？<a href=\"post/algorithm-dp#我该怎么才能得到最多的钱？\"></a></h2><p>不管你是什么工作，或者你是个学生。现在，你失去了所有，你是一个临时工。公司给临时工分配了一些任务，你需要在指定时间段内完成任务，每个任务有不同的工资，你需要在这些任务里寻求一个最优的组合让你能拿到最多的工资。</p>\n<p>我们的输入是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[(1,4,5),(3,5,1),(0,6,8),(4,7,4),(3,8,6),(5,9,3),(6,10,2),(8,11,4)]</span><br></pre></td></tr></table></figure>\n<p>列表中的每一个元组代表一个任务，元组中的第一个元素代表起始时间，第二个元素代表结束时间，第三个元素代表你能拿到的工资。这些任务有可能是互斥的，比如第一个任务和第二个任务你不能同时做，因为第一个任务的结束时间是4，而第二个任务的起始时间是3，你大概不能在3点到4点之间分身同时去完成两个任务。</p>\n<p>如果我们画出图像，我们很容易看出最优的组合是第1个，第4个和第8个，全部做完你可以得到13软妹币。</p>\n<div class=\"article-img\"><p><img src=\"https://s2.ax1x.com/2020/01/23/1E4zxf.jpg\" alt data-zoomable></p></div>\n<p><em>PS：图中的任务是按照1~8排列的，但是我们实际写代码用的是0~7，这是作图时的疏忽</em></p>\n<p>进行第一步，分解子任务。<br>假设我们有一个函数opt用于寻找最优解，对于每个任务，都有选择或者不选的状态，假设我们选了最后一个任务，那么我们就已经有了4软妹币的收益，但是对于倒数第二个和倒数第三个任务我们就不能选了，因为它们是互斥的，这时我们能获得的最优收益就是最后一个的收益加上前五个中的最优解。如果我们不选，那么结果就是从第一个到倒数第二个中再计算最优解，最后我们选两个选法里面最大的一个作为最后的最优解。这就构成了递归：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">opt(i) = max&#123;vi + opt(prev(i)) , opt(i-1)&#125;</span><br></pre></td></tr></table></figure>\n<p><em>vi是任务i的收益，prev函数是用来寻找前面的任务中最近的不互斥的任务。</em></p>\n<p>确定边界和初始条件<br>有递归就要有出口，本题的出口就是当i已经是0的时候，还有就是已经不存在prev的时候。<br>初始条件是对于opt(0)，我们直接返回第0个任务能得到的钱数就好了，因为这个时候我们的最优解只是选中它。</p>\n<p>所以我们开始写代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">prev</span><span class=\"params\">(arr,i)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> reversed(range(<span class=\"number\">0</span>,i + <span class=\"number\">1</span>)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> arr[j][<span class=\"number\">1</span>] &lt;= arr[i][<span class=\"number\">0</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> j</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dp_opt</span><span class=\"params\">(arr)</span>:</span></span><br><span class=\"line\">    optarr = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>,len(arr))]</span><br><span class=\"line\">    optarr[<span class=\"number\">0</span>] = arr[<span class=\"number\">0</span>][<span class=\"number\">2</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,len(arr)):</span><br><span class=\"line\">        A = arr[i][<span class=\"number\">2</span>] + optarr[prev(arr,i)]</span><br><span class=\"line\">        B = optarr[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">        optarr[i] = max(A,B)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> optarr[len(optarr) - <span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    tasks = [(<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>),(<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">1</span>),(<span class=\"number\">0</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>),(<span class=\"number\">4</span>,<span class=\"number\">7</span>,<span class=\"number\">4</span>),(<span class=\"number\">3</span>,<span class=\"number\">8</span>,<span class=\"number\">6</span>),(<span class=\"number\">5</span>,<span class=\"number\">9</span>,<span class=\"number\">3</span>),(<span class=\"number\">6</span>,<span class=\"number\">10</span>,<span class=\"number\">2</span>),(<span class=\"number\">8</span>,<span class=\"number\">11</span>,<span class=\"number\">4</span>)]</span><br><span class=\"line\">    result2 = dp_opt(tasks)</span><br><span class=\"line\">    print(result2)</span><br><span class=\"line\"></span><br><span class=\"line\">main()</span><br></pre></td></tr></table></figure>\n<h2 id=\"买股票的最佳时机\">买股票的最佳时机<a href=\"post/algorithm-dp#买股票的最佳时机\"></a></h2><p>此题为leetcode的第121道：<a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock\" target=\"_blank\" rel=\"noopener\">买股票的最佳时机</a></p>\n<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>\n<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>\n<p>注意你不能在买入股票前卖出股票。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: [7,1,5,3,6,4]</span><br><span class=\"line\">输出: 5</span><br><span class=\"line\">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class=\"line\">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br><span class=\"line\">示例 2:</span><br><span class=\"line\"></span><br><span class=\"line\">输入: [7,6,4,3,1]</span><br><span class=\"line\">输出: 0</span><br><span class=\"line\">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>\n<p>我们尝试找到该题的递归关系，从后往前，第i天还是有两种可能，就是卖或者不卖，如果卖了，最大收益就是第i天的价格减去前面最低的价格。如果不卖，就再对前一个元素做这种递归调用，然后选两次最大的。</p>\n<p>递归出口为当i等于0时，如果这天卖的话，前面没有可以买的日子了，所以根据规则你应该返回0。</p>\n<p>写代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProfitDP</span><span class=\"params\">(prices)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(prices) == <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    minPrice,profit = prices[<span class=\"number\">0</span>],<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,len(prices)):</span><br><span class=\"line\">        minPrice = min(minPrice,prices[i])</span><br><span class=\"line\">        profit = max(profit,prices[i]-minPrice)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> profit</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxProfit</span><span class=\"params\">(self, prices: List[int])</span> -&gt; int:</span> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxProfitDP(prices)</span><br></pre></td></tr></table></figure>\n<p>我们通过记录最低价格和收益来达到目标，最终把时间复杂度限制在了O(n)，并且代码变得简洁明了。</p>\n<h2 id=\"交换硬币\">交换硬币<a href=\"post/algorithm-dp#交换硬币\"></a></h2><p>该题目来自<a href=\"https://www.lintcode.com/problem/coin-change/description\" target=\"_blank\" rel=\"noopener\">LintCode 699</a></p>\n<p>给出不同面额的硬币以及一个总金额. 写一个方法来计算给出的总金额可以换取的最少的硬币数量. 如果已有硬币的任意组合均无法与总金额面额相等, 那么返回 -1.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">样例1</span><br><span class=\"line\"></span><br><span class=\"line\">输入：</span><br><span class=\"line\">[1, 2, 5]</span><br><span class=\"line\">11</span><br><span class=\"line\">输出： 3</span><br><span class=\"line\">解释： 11 = 5 + 5 + 1</span><br><span class=\"line\"></span><br><span class=\"line\">样例2</span><br><span class=\"line\"></span><br><span class=\"line\">输入： </span><br><span class=\"line\">[2]</span><br><span class=\"line\">3</span><br><span class=\"line\">输出： -1</span><br></pre></td></tr></table></figure>\n<p>对于该问题，我们先寻找子问题构造递归式。假设我们面对的只是样例1中的问题，我们有<code>[1,2,5]</code>这三种硬币，如何用最少的硬币数量换取11块钱。</p>\n<p>我们假设我们用了如下k枚硬币排列凑齐了总额11元：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1,2,3,...,k</span><br></pre></td></tr></table></figure></p>\n<p>数列a表示这些硬币的面值：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a1,a2,a3,...,ak</span><br></pre></td></tr></table></figure></p>\n<p>那么这些硬币可以分成<code>[0,k-1]</code>和<code>(k-1,k]</code>两个区间，后一个区间里只有k，如果有f(a)函数计算当需要凑的总额为a时的最少金币数的话，那么：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(a) = f(a-ak) + 1</span><br></pre></td></tr></table></figure></p>\n<p>不过我们现在不知道ak是啥，所以我们要把所有面值的硬币都试一试，然后取最小值，得出如下递归式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(a) = min&#123; f(a-5) + 1 , f(a-2) + 1 , f(a-1) + 1 &#125;</span><br></pre></td></tr></table></figure></p>\n<p>再看看边界条件和初始值<br>边界条件是当a为0时（正好凑齐）返回0，a为负数时（当前所选的路凑不齐）时返回正无穷。初始值是f(0)为0，因为总额为0时根本不用凑。</p>\n<p>编写代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dp</span><span class=\"params\">(c,a)</span>:</span></span><br><span class=\"line\">    f = [<span class=\"number\">-1</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>,a+<span class=\"number\">1</span>)]</span><br><span class=\"line\">    f[<span class=\"number\">0</span>] = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,len(f)):</span><br><span class=\"line\">        <span class=\"comment\"># 生成正无穷</span></span><br><span class=\"line\">        f[i] = float(<span class=\"string\">\"inf\"</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 遍历所有硬币面值</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> ci <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>,len(c)):</span><br><span class=\"line\">            lastI = i - c[ci]</span><br><span class=\"line\">            <span class=\"comment\"># 这个if排除凑不出的情况</span></span><br><span class=\"line\">            <span class=\"comment\"># math.isinf(x)判断x是否是正无穷</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> lastI &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> math.isinf(f[lastI]):</span><br><span class=\"line\">                f[i] = min(f[lastI] + <span class=\"number\">1</span>,f[i])</span><br><span class=\"line\">    <span class=\"comment\"># 如果是无穷则直接返回-1 表示凑不出</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> math.isinf(f[a]):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> f[a]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"不同的路径\">不同的路径<a href=\"post/algorithm-dp#不同的路径\"></a></h2><p>本题来自<a href=\"https://www.lintcode.com/problem/unique-paths/description\" target=\"_blank\" rel=\"noopener\">LintCode 114</a></p>\n<p>有一个机器人的位于一个 m × n 个网格左上角。</p>\n<p>机器人每一时刻只能向下或者向右移动一步。机器人试图达到网格的右下角。</p>\n<p>问有多少条不同的路径？<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Example 1:</span><br><span class=\"line\"></span><br><span class=\"line\">Input: n = 1, m = 3</span><br><span class=\"line\">Output: 1\t</span><br><span class=\"line\">Explanation: Only one path to target position.</span><br><span class=\"line\"></span><br><span class=\"line\">Example 2:</span><br><span class=\"line\"></span><br><span class=\"line\">Input:  n = 3, m = 3</span><br><span class=\"line\">Output: 6\t</span><br><span class=\"line\">Explanation:</span><br><span class=\"line\">\tD : Down</span><br><span class=\"line\">\tR : Right</span><br><span class=\"line\">\t1) DDRR</span><br><span class=\"line\">\t2) DRDR</span><br><span class=\"line\">\t3) DRRD</span><br><span class=\"line\">\t4) RRDD</span><br><span class=\"line\">\t5) RDRD</span><br><span class=\"line\">\t6) RDDR</span><br></pre></td></tr></table></figure></p>\n<p>…未完并且表示不想写了…</p>\n","next":{"title":"GO语言笔记和习题","slug":"go-go1"},"link":"http://lilpig.site/post/algorithm-dp/","toc":[{"title":"","id":"在纸上写-“1-1-1-1-1-1-1-1-”","index":"1"},{"title":"","id":"小朋友掰手指数数中…","index":"2"},{"title":"","id":"再在左边填一个”1-”","index":"3"},{"title":"","id":"很快","index":"4","children":[{"title":"斐波那契热身","id":"斐波那契热身","index":"4.1"},{"title":"动态规划问题的求解套路","id":"动态规划问题的求解套路","index":"4.2"},{"title":"我该怎么才能得到最多的钱？","id":"我该怎么才能得到最多的钱？","index":"4.3"},{"title":"买股票的最佳时机","id":"买股票的最佳时机","index":"4.4"},{"title":"交换硬币","id":"交换硬币","index":"4.5"},{"title":"不同的路径","id":"不同的路径","index":"4.6"}]}],"reward":true,"copyright":{"author":"LIL PIG","link":"<a href=\"http://lilpig.site/post/algorithm-dp/\" title=\"动态规划\">http://lilpig.site/post/algorithm-dp/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}