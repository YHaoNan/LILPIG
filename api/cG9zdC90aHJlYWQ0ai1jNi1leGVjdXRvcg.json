{"title":"（五）任务执行 —— 《Java并发编程实战》","date":"2019-07-30T02:54:30.000Z","slug":"thread4j-c6-executor","tags":["java","thread"],"categories":["Java多线程"],"updated":"2019-07-30T05:32:03.066Z","content":"<p>在高并发应用中，如果把所有任务都放在一个线程中串行执行，那么会造成阻塞，导致我们的应用看起来奇慢无比，而且没有很好的利用CPU的资源。但如果我们给每个任务都创建一个线程，无节制的创建可能还会导致我们的资源被耗尽，然后发生一些不可预测的事情，并且每次请求都创建一个Thread，并在结束后销毁它这种做法在创建和销毁对象上浪费了很多资源，还会给Java的垃圾回收器带来一定的压力。</p>\n<p>Java给我们提供了一些工具，可以通过它们来管理这些任务的执行流程，比如串行执行、并行执行，还可以设置一些限制，比如最大线程数等等，通过这些你可以灵活的控制你的任务。</p>\n<p>我们先创建一个服务器模型，今天所有的代码都将在这个模型上修改。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SyncServer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ServerSocket server = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">80</span>);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">                Socket socket = server.accept();</span><br><span class=\"line\">                handleSocket(socket);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">handleSocket</span><span class=\"params\">(Socket socket)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">        socket.getOutputStream().write(<span class=\"string\">\"HelloWorld!\"</span>.getBytes());</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">        socket.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个单线程的简单的服务器，只要有连接过来，服务器就返回<code>HelloWorld</code>，然后等待500毫秒之后关闭，这个500毫秒我们用于模拟耗时操作，先在我们用nc来模拟连接：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nc localhost 80 &amp; nc localhost 80</span><br></pre></td></tr></table></figure></p>\n<p>我们通过<code>&amp;</code>让两条命令同步执行，结果发现两个输出还是间隔了一些，就是我们设置的<code>500</code>毫秒。</p>\n<p>下面我们会用各种类型的任务执行器来对这个示例进行改进。</p>\n<h2 id=\"Executor\">Executor<a href=\"post/thread4j-c6-executor#Executor\"></a></h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Executor</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是<code>Executor</code>接口的定义，Java中有很多<code>Executor</code>的实现类用于我们对我们的任务进行控制，下面我们使用<code>Executor</code>对之前的单线程服务器进行修改。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AsyncServerWithFixedThreadPool</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Executor executor = Executors.newFixedThreadPool(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ServerSocket server = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">80</span>);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>)&#123;</span><br><span class=\"line\">                Socket socket = server.accept();</span><br><span class=\"line\">                Runnable task = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                    <span class=\"meta\">@Override</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            handleSocket(socket);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125; </span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">                executor.execute(task);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">handleSocket</span><span class=\"params\">(Socket socket)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class=\"line\">        socket.getOutputStream().write(<span class=\"string\">\"HelloWorld!\"</span>.getBytes());</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">        socket.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码使用<code>Executor</code>实现了多线程服务器，用<code>Executors.newXXXXXThreadPool</code>创建了一个线程池，代码中用的是<code>newFixedThreadPool</code>，这个线程池可以指定一个最大线程数，如果线程池为空或者没有空闲线程，会为新请求创建一个线程，当然是没有到达最大线程数的情况，如果到达最大线程数则会产生阻塞，直到某个线程执行完毕后转换为空闲状态时执行。</p>\n<p>每一个<code>Executor</code>实现都有自己对任务控制的逻辑，看看JVM中其他的线程池的控制机制吧：</p>\n<ul>\n<li>newFixedThreadPool<br>  如上描述</li>\n<li>newCachedThreadPool<br>  一个可缓存的线程池，它没有最大线程数，或者说它的最大线程数是<code>int</code>类型最大值，它可以为每个新建的线程设置一个超时时间，如果处于空闲状态的时间超过超时时间，这个线程将被销毁。如果在没有超过timeout的空闲时间内接收到了请求任务，则执行。当需求增加并没有多余线程时，增加线程池中线程数量。它的好处是回收机制保证了不会有很多空闲的线程。</li>\n<li>newSingleThreadExecutor<br>  一个单线程的Executor，任务串行执行，但是能保证执行的顺序（FIFO、LIFO、优先级）</li>\n<li>newScheduledThreadPool<br>  提供固定大小的线程池，并且以延时方式执行任务</li>\n</ul>\n<h2 id=\"停止执行\">停止执行<a href=\"post/thread4j-c6-executor#停止执行\"></a></h2><p>如果全用<code>Executor</code>来控制，那么停止貌似就成了一个问题，把所有线程全部停止可不像想象中那么简单，直接停止线程在Java中是不允许的，因为这可能造成数据丢失等问题，所以多线程中让线程停止其实可以看作是和线程进行协商的过程，如果你了解<code>interrupt</code>方法你应该理解了这段话。</p>\n<p><code>Executor</code>扩展了<code>ExecutorService</code>接口，提供了一些生命周期方法，其中一些用于停止的方法如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ExecutorService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Executor</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">List&lt;Runnable&gt; <span class=\"title\">shutdownNow</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isShutdown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isTerminated</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">awaitTermination</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout,TimeUnit unit)</span> </span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>ExecutorService</code>生命周期有三种状态，分别是运行、关闭和已终止，初始创建时是运行状态，<code>shutdown</code>是平缓关闭，即不接受新的任务，但是等待已经提交的任务完成，包括已经提交但未开始的任务。<code>shutdownNow</code>则粗暴的尝试取消所有运行中的任务，并且队列中没有开始执行的任务不会被启动。</p>\n<p><code>ExecutorService</code>属于关闭状态时提交的任务将被拒绝，可能会抛出一个未检查的<code>RejectedExecutionException</code>，当所有任务都完成后，<code>ExecutorService</code>将进入终止状态。</p>\n<p><code>awaitTermination</code>方法等待<code>ExecutorService</code>达到终止状态，<code>isTerminated</code>返回是否终止。</p>\n<p>下一篇会详细介绍关闭和取消任务。</p>\n<h2 id=\"Callable和Future\">Callable和Future<a href=\"post/thread4j-c6-executor#Callable和Future\"></a></h2><p><code>Executor</code>使用<code>Runnable</code>有一些局限性，<code>Runnable</code>的接口决定了它不能有返回值，不能向上抛出异常，许多任务都需要返回结果，所以<code>Runnable</code>并不能适合所有的场景，<code>Callable</code>可以代替它，它是这样的：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>它有返回结果和异常声明。</p>\n<p><code>Future</code>表示一个任务的生命周期，它有几个状态：未开始、运行中<br>完成，它除了可以获取任务执行的结果外还可以判断是否已经完成、是否已经取消，还可以手动取消任务等。</p>\n<p><code>Future</code>的<code>get</code>方法用于获取任务结果，如果任务处于完成状态，它会立即返回或抛出异常，分别对应成功或失败（异常或取消），如果任务运行中则会一直阻塞到完成。</p>\n<p>任务如果被取消则会抛出<code>CancellationException</code>，如果是任务运行时出现了异常则会抛出<code>ExecutionException</code>，不管抛出的是什么异常都会封装成这个，可以通过<code>getCause</code>获得原始异常。</p>\n<p><code>ExecutorService</code>的所有<code>submit</code>方法都返回一个<code>Future</code>，你需要传入<code>Runnable</code>或<code>Callable</code>代表任务，可以通过返回的<code>Future</code>获取任务结果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImageDownloader</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String[] imgs;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ExecutorService service;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Future&lt;String&gt;&gt; futures;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ImageDownloader</span><span class=\"params\">(String[] imgs)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.imgs = imgs;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.service = Executors.newFixedThreadPool(imgs.length);</span><br><span class=\"line\">        futures = Collections.synchronizedList(<span class=\"keyword\">new</span> ArrayList());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startDownload</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String img:imgs)&#123;</span><br><span class=\"line\">            Callable&lt;String&gt; callable = <span class=\"keyword\">new</span> Callable&lt;String&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> DownloadUtils.download(img);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            futures.add(service.submit(callable));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;futures.size();i++)&#123;</span><br><span class=\"line\">            System.out.println(futures.get(i).get());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> ImageDownloader(图片列表).startDownload();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码用<code>Callable</code>和<code>Future</code>实现了一个图片下载器，<code>Future</code>会返回图片的保存路径，当然<code>DownloadUtils</code>我没放出来，你需要自己实现。</p>\n<p>这个虽然在<code>ExecutorService</code>中所有图片是并发下载的，但是我们后面获取下载结果的操作是串行执行的，如果我们下载完图片还需要进行渲染到界面上，那么假设第一个图片下载用了10秒，其他的图片都只用了0.1秒，实际上用户还是要等第一个图片下载完才能看到后面的图片，尽管后面的图片早就下载完毕，这是个问题。我们可以用<code>CompletionService</code>解决。</p>\n<h2 id=\"CompletionService\">CompletionService<a href=\"post/thread4j-c6-executor#CompletionService\"></a></h2><p><code>ExecutorCompletionService</code>是<code>CompletionService</code>的一个实现类，它使用阻塞队列把每个<code>submit</code>的任务执行结果添加进去，然后我们可以直接使用阻塞队列的<code>take</code>方法，每当有一个任务完成，我们就可以同时取出结果。这是一个生产者消费者模式，我们就是消费者角色。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImageDownloader</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String[] imgs;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ExecutorService service;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ImageDownloader</span><span class=\"params\">(String[] imgs)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.imgs = imgs;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.service = Executors.newFixedThreadPool(imgs.length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startDownload</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\">        ExecutorCompletionService&lt;String&gt; completionService = <span class=\"keyword\">new</span> ExecutorCompletionService&lt;&gt;(service);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String img:imgs)&#123;</span><br><span class=\"line\">            Callable&lt;String&gt; callable = <span class=\"keyword\">new</span> Callable&lt;String&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> DownloadUtils.download(img);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            completionService.submit(callable);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;imgs.length;i++)&#123;</span><br><span class=\"line\">            System.out.println(completionService.take());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> ImageDownloader(<span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"http://nsimg.cn-bj.ufileos.com/img-1562809043876.jpg\"</span></span><br><span class=\"line\">                ,<span class=\"string\">\"http://nsimg.cn-bj.ufileos.com/img-1563418446349.jpg\"</span>,<span class=\"string\">\"http://nsimg.cn-bj.ufileos.com/img-1563750980266.jpg\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"http://nsimg.cn-bj.ufileos.com/img-1563751115703.jpg\"</span>,<span class=\"string\">\"http://nsimg.cn-bj.ufileos.com/img-1564023283075.jpg\"</span>&#125;)</span><br><span class=\"line\">        .startDownload();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Future</code>和<code>Executor</code>还有很多方法，比如定时、调用全部什么的，不多介绍了，去看看API吧！</p>\n","prev":{"title":"（六）线程取消和关闭 —— 《Java并发编程实战》","slug":"thread4j-c7-stop"},"next":{"title":"（四）基础构建模块 —— 《Java并发编程实战》","slug":"thread4j-c5-builtin-module"},"link":"http://lilpig.site/post/thread4j-c6-executor/","toc":[{"title":"Executor","id":"Executor","index":"1"},{"title":"停止执行","id":"停止执行","index":"2"},{"title":"Callable和Future","id":"Callable和Future","index":"3"},{"title":"CompletionService","id":"CompletionService","index":"4"}],"reward":true,"copyright":{"author":"LIL PIG","link":"<a href=\"http://lilpig.site/post/thread4j-c6-executor/\" title=\"（五）任务执行 —— 《Java并发编程实战》\">http://lilpig.site/post/thread4j-c6-executor/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}