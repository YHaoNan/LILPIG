{"title":"（二）数据可见性以及共享对象 —— Java多线程学习","date":"2019-07-26T11:13:30.000Z","slug":"thread4j-c3-obj-share","tags":["java","thread"],"categories":["Java多线程"],"updated":"2019-07-26T12:23:21.465Z","content":"<p>从上一篇文章中可以知道，同步代码块，也就是<code>synchronized</code>标识的代码块可以保证一个操作的原子性，即不可分割，保证了不会出现竞态条件，其他线程读取到的值不会错乱。</p>\n<p>但是<code>synchronized</code>并不是只干了这一件事，他还保证了数据的可见性。</p>\n<h2 id=\"什么是可见性\">什么是可见性<a href=\"post/thread4j-c3-obj-share#什么是可见性\"></a></h2><p>可见性即能保证一个线程修改了一个数据之后，这个数据对另一个线程是可见的。</p>\n<p>可见性说起来简单，但是却很难理解，因为它里面的很多东西都是违背我们的认知规律并且难以用示例说明的。</p>\n<p>你可能会对可见性产生疑问，既然使用<code>synchronized</code>时只能有一个线程进行操作，所有线程都是顺序通过的，那怎么会有可见性问题？如果线程A先争抢到锁之后，把数据改了，那么当它释放锁，线程B得到锁的时候，这个数据已经改完了啊，这和单线程串行程序的道理是一样的，那么A改的数据对B，对其他后来线程肯定是可见的啊。为什么会把<code>synchronized</code>能保证可见性这件显而易见的事拿出来单说？</p>\n<p>没那么简单，我要告诉你一件事，可能会颠覆你的三观，但是这件事确实是真的，那就是：</p>\n<blockquote>\n<p>即使在单线程程序中，每条代码也不一定是顺序执行的</p>\n</blockquote>\n<p>没错，我也被震惊到了，但是事实就是这样，即使感觉上这件事违背了常理。</p>\n<p>代码执行的时候，内存的速度远比cpu的运算速度要慢，为了能发挥出cpu的最优性能，会将代码经过多层重排序，编译器会按照一定的规则将指令重排，指令到了cpu，cpu又会根据自己的规则对指令进行重排。比如下面的单线程代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure></p>\n<p>不要直接认为第一行先于第二行执行，这实际上是没准的事，不过重排序肯定会遵循一些规则，否则我们的代码逻辑就乱了套了。</p>\n<p>重排序遵循<code>as-if-serial</code>语义，这名字直译过来是“好像是连续的…”，我们简单了解下这个语义。</p>\n<p>对代码进行重排要满足数据依赖性，如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖。如果存在数据依赖，那么重排就会影响代码的执行结果，<code>as-if-serial</code>语义保证了在单线程程序中重排不会影响代码执行结果。</p>\n<p>但是多线程的话，程序的执行结果无法预判，所以编译器不好从语义上判断数据是否存在依赖性，所以<code>as-if-serial</code>在多线程程序中保证不了数据不会混乱，这下就出现了数据可见性问题。</p>\n<p>看一个简单的例子就能说明这个问题了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> site.lilpig.tlearn02;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataVisiableSample</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> num;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> flag;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">1000</span>;i++)&#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            Thread t1 = <span class=\"keyword\">new</span> Thread()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">                    num = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    flag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">            Thread t2 = <span class=\"keyword\">new</span> Thread()&#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">super</span>.run();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (flag &amp;&amp; num == <span class=\"number\">0</span>)</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"ERROR...\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">            t1.start();</span><br><span class=\"line\">            t2.start();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//等待线程1和线程2执行完重置num和flag进行下一次循环</span></span><br><span class=\"line\">            t1.join();</span><br><span class=\"line\">            t2.join();</span><br><span class=\"line\">            num = <span class=\"number\">0</span>;</span><br><span class=\"line\">            flag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码使用了两个线程，线程1设置<code>num</code>为1并且设置<code>flag</code>为true，通知线程2<code>num</code>已经设置为1了。线程2判断，如果<code>flag</code>为true并且<code>num</code>为0就证明线程1中执行的代码被重排了。因为如果在线程1中的代码如果按顺序执行的话这个条件不可能是true。</p>\n<p>然而别说一千次，我执行了几十万次也没遇到过一次重排，这应当是个极小的概率事件吧，我们理解就好。</p>\n<p>上面的例子说明了由于重排导致的可见性问题确实存在，虽然没有真正的把这个现象重现出来，但是并不代表它不存在，万一上帝就是那么偏爱你，你也没有办法，所以在多线程代码中我们要预防它的发生，否则可能会出现很大的问题。</p>\n<p>对了，别忘了我之前说过</p>\n<p><span style=\"font-size:1.3em\">synchronized会在一个线程退出后同步所有操作，所以能保证数据对其他线程的可见性和有效性</span></p>\n<h2 id=\"最低安全性\">最低安全性<a href=\"post/thread4j-c3-obj-share#最低安全性\"></a></h2><p>Java可以保证就算可见性问题发生了，某个线程读到了失效的数据，但这个数据也是以前某个时刻某个线程设置过的，而不是一个随机值，如果做一些对数据要求不太精确的应用，比如网页访问时的计数器时，最低安全性还是能给我们一个保障的。</p>\n<p>不过有一个例外，非原子的64位变量比如<code>long</code>和<code>double</code>无法保证最低安全性，JVM允许把它们的读取和写入操作分成两次，一次操作32位，所以如果发生了可见性问题，有可能读到的数据前32位是之前设置过的一个值的前32位，后32位是另一个之前设置过的值的后32位，这样就会出现问题。</p>\n<p>解决办法是用<code>volatile</code>关键字声明它们或者用<code>synchronized</code>保护它们。</p>\n<h2 id=\"volatile变量\">volatile变量<a href=\"post/thread4j-c3-obj-share#volatile变量\"></a></h2><p>声明成<code>volatile</code>的变量编译器和运行时都会知道它是要和其他线程共享的，所以不会让它参与重排，也就不会出现数据失效的问题，其他线程读到的始终都是最新的数据。</p>\n<p>不过它和锁可没任何关系，该加锁的地方还是加锁。</p>\n<p>对于<code>volatile</code>关键字的应用，把上面代码的<code>num</code>和<code>flag</code>都加上这个关键字就好了，不会重排就不会出现问题，<code>flag &amp;&amp; num == 0</code>也永远不会成立。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> num;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> flag;</span><br></pre></td></tr></table></figure>\n<p>因为<code>volatile</code>不会产生阻塞，只是保证变量不会被重排，所以它也保证不了操作的原子性。</p>\n<p>未完…先睡…</p>\n<hr>\n<h2 id=\"参考\">参考<a href=\"post/thread4j-c3-obj-share#参考\"></a></h2><ul>\n<li><a href=\"https://www.cnblogs.com/gtaxmjld/p/5274779.html\" target=\"_blank\" rel=\"noopener\">多线程之指令重排序</a></li>\n</ul>\n","next":{"title":"Nodejs中的异步编程 -- Promise","slug":"nodejs-promise"},"link":"http://lilpig.site/post/thread4j-c3-obj-share/","toc":[{"title":"什么是可见性","id":"什么是可见性","index":"1"},{"title":"最低安全性","id":"最低安全性","index":"2"},{"title":"volatile变量","id":"volatile变量","index":"3"},{"title":"参考","id":"参考","index":"4"}],"reward":true,"copyright":{"author":"LIL PIG","link":"<a href=\"http://lilpig.site/post/thread4j-c3-obj-share/\" title=\"（二）数据可见性以及共享对象 —— Java多线程学习\">http://lilpig.site/post/thread4j-c3-obj-share/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}