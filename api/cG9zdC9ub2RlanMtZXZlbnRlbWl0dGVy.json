{"title":"事件发射器-NodeJS","date":"2019-07-01T21:44:12.000Z","slug":"nodejs-eventemitter","tags":["nodejs"],"categories":["NodeJS"],"updated":"2019-07-17T00:50:16.754Z","content":"<h2 id=\"标准回调模式\">标准回调模式<a href=\"post/nodejs-eventemitter#标准回调模式\"></a></h2><p>回调肯定都用过，就是函数不使用返回值，而是让调用者提供一个回调函数，可以有一些参数，如果函数执行完了再调用这个回调函数通知调用者处理结果。</p>\n<p>比如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\">fs.readFile(<span class=\"string\">'/etc/passwd/'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,fileContent</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'发生错误'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(fileContent.toString());</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>回调有一个好处，它适合异步编程，因为异步编程时你所在的主线程并不会等函数中的子线程执行完毕，函数没有执行完毕就返回了，这会返回不正确的结果，而回调则不会。</p>\n<h2 id=\"事件发射器\">事件发射器<a href=\"post/nodejs-eventemitter#事件发射器\"></a></h2><p>回调也有局限性，比如我们想接受多种事件的回调，而且有的事件可能会被触发多次，比如读取socket中的所有数据，这用标准回调模式时我们需要自己写很多代码，至少要是这样的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xxx(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(event == A)</span><br><span class=\"line\">        doA();</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(event == B)</span><br><span class=\"line\">        doB();</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>这里我们提供了一个event来确定回调的类型，这样很不方便，nodejs提供了一个事件发射器的模型，可以方便的实现这些功能，比如http模块就使用了它：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> req = http.request(options,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>)</span>&#123;</span><br><span class=\"line\">    response.on(<span class=\"string\">'data'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    response.on(<span class=\"string\">'end'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'Response ended!'</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">req.end();</span><br></pre></td></tr></table></figure></p>\n<p>在这里我们可以用<code>on</code>来接受一个事件，当接收到<code>data</code>事件时，后面的回调就会被触发。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">util = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> EventEmitter = <span class=\"built_in\">require</span>(<span class=\"string\">'events'</span>).EventEmitter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Ticker = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        self.emit(<span class=\"string\">'tick'</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使Ticker继承自EventEmitter</span></span><br><span class=\"line\">util.inherits(Ticker,EventEmitter);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ticker = <span class=\"keyword\">new</span> Ticker();</span><br><span class=\"line\">ticker.on(<span class=\"string\">'tick'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'tiktok!'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>使用EventEmitter的emit方法可以发射一个事件，我们在上面的代码中每秒发射一个tick事件，然后在下面监听tick事件，一旦被触发就向控制台输出一行字符串。</p>\n<p>运行它，你会发现每隔一秒控制台都会输出一行<code>tiktok！</code></p>\n<p>EventEmitter有如下方法：</p>\n<ul>\n<li>on(event,callback) 注册一个事件监听器</li>\n<li>addListener(event,callback) 同on</li>\n<li>removeListener(event,callback) 移除一个监听器</li>\n<li>removeAllListener(event) 移除一个事件下的所有监听器</li>\n<li>once(event,callback) 注册一个事件监听器，这个监听器只会被触发一次，之后就会被移除</li>\n</ul>\n","prev":{"title":"图简单实现以及深度优先搜索和广度优先搜索","slug":"algorithm-graph"},"next":{"title":"BST、2-3树、红黑树和散列函数实现符号表","slug":"algorithm-table"},"link":"http://lilpig.site/post/nodejs-eventemitter/","toc":[{"title":"标准回调模式","id":"标准回调模式","index":"1"},{"title":"事件发射器","id":"事件发射器","index":"2"}],"reward":true,"copyright":{"author":"LIL PIG","link":"<a href=\"http://lilpig.site/post/nodejs-eventemitter/\" title=\"事件发射器-NodeJS\">http://lilpig.site/post/nodejs-eventemitter/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}