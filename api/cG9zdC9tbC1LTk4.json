{"title":"KNN算法","date":"2019-05-17T03:01:27.000Z","slug":"ml-KNN","tags":["python","机器学习"],"categories":["机器学习"],"updated":"2019-05-29T09:01:32.000Z","content":"<p>今早自己瞎实现了一个KNN算法，觉得挺简单，感觉我踏入机器学习领域就是很快的事。然后刷了下吴恩达老师的课，瞬间懵逼。。数学不行还是别来了，我先去学数学了。(不过老师讲得很好，最起码一个中专生都听懂了不少)</p>\n<p>KNN是一个分类算法，就是K近邻算法，就是在若干数据中找出K个与输入数据最近的数据，然后看一下它们中哪一类是最多的，就预测输入数据属于哪一类。</p>\n<p>这个算法可以说非常简单了，其实整个算法就用到了一个公式，就是欧里几德距离。</p>\n<p>$<br>dist(X,Y)=\\sqrt{\\sum\\limits_{i=1}^{N} (x_i-y_i)^2}<br>$</p>\n<p>其中，X和Y是N维空间里的两个点，业务中它们就是有N个属性的两个不同的数据，然后对它们每个维度所在的位置做差，平方然后求和，最后开根号。</p>\n<p>假设我需要通过各种镜头的次数判断一个电影属于什么类型，并给如下数据集：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tag_name = [<span class=\"string\">'爱情动作片'</span>,<span class=\"string\">'爱情片'</span>,<span class=\"string\">'动作片'</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">//每一行的第一个元素表示接吻镜头，第二个元素表示武打镜头</span><br><span class=\"line\">train_data = np.array([[<span class=\"number\">25</span>,<span class=\"number\">32</span>],</span><br><span class=\"line\">                       [<span class=\"number\">65</span>,<span class=\"number\">21</span>],</span><br><span class=\"line\">                       [<span class=\"number\">135</span>,<span class=\"number\">42</span>],</span><br><span class=\"line\">                       [<span class=\"number\">32</span>,<span class=\"number\">0</span>],</span><br><span class=\"line\">                       [<span class=\"number\">15</span>,<span class=\"number\">62</span>],</span><br><span class=\"line\">                       [<span class=\"number\">11</span>,<span class=\"number\">2</span>],</span><br><span class=\"line\">                       [<span class=\"number\">66</span>,<span class=\"number\">10</span>],</span><br><span class=\"line\">                       [<span class=\"number\">55</span>,<span class=\"number\">49</span>],</span><br><span class=\"line\">                       [<span class=\"number\">1</span>,<span class=\"number\">52</span>],</span><br><span class=\"line\">                       [<span class=\"number\">2</span>,<span class=\"number\">30</span>],</span><br><span class=\"line\">                       [<span class=\"number\">65</span>,<span class=\"number\">122</span>],</span><br><span class=\"line\">                       [<span class=\"number\">12</span>,<span class=\"number\">15</span>],</span><br><span class=\"line\">                       [<span class=\"number\">30</span>,<span class=\"number\">33</span>],</span><br><span class=\"line\">                       [<span class=\"number\">65</span>,<span class=\"number\">69</span>]])</span><br><span class=\"line\">//tag表示训练数据中对应位置的片子的类型</span><br><span class=\"line\">train_tag = np.array([<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>])</span><br></pre></td></tr></table></figure></p>\n<p>这时，我需要通过一个函数<code>g</code>来预测其他电影的类型。比如：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>g([<span class=\"number\">65</span>,<span class=\"number\">21</span>])</span><br><span class=\"line\">爱情片</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">g</span><span class=\"params\">(attr,k=<span class=\"number\">3</span>)</span>:</span></span><br><span class=\"line\">    //生成距离列表</span><br><span class=\"line\">    distance_list = [<span class=\"number\">0</span>] * len(train_data)</span><br><span class=\"line\">    //计算每一个训练数据和输入数据的欧氏距离</span><br><span class=\"line\">    <span class=\"keyword\">for</span> index,m <span class=\"keyword\">in</span> enumerate(train_data):</span><br><span class=\"line\">        d = math.sqrt((attr[<span class=\"number\">0</span>]-m[<span class=\"number\">0</span>])**<span class=\"number\">2</span>+(attr[<span class=\"number\">1</span>]-m[<span class=\"number\">1</span>])**<span class=\"number\">2</span>)</span><br><span class=\"line\">        distance_list[index] = (d,train_tag[index])</span><br><span class=\"line\">    //排序并取前k个</span><br><span class=\"line\">    distance_list = sorted(distance_list)[<span class=\"number\">0</span>:k]</span><br><span class=\"line\">    //n记录前k个中出现的每个类别的个数</span><br><span class=\"line\">    n = [<span class=\"number\">0</span>]*<span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> distance_list:</span><br><span class=\"line\">        n[d[<span class=\"number\">1</span>]] = n[d[<span class=\"number\">1</span>]] + <span class=\"number\">1</span></span><br><span class=\"line\">    max_p = n.index(max(n))</span><br><span class=\"line\">    print(tag_name[max_p])</span><br></pre></td></tr></table></figure>\n<p>大概就是这样，这个是最简单的机器学习中的有监督分类算法，我自己瞎写的，如果有不对的地方欢迎指正。不说了，得学数学去了。[手动哭]</p>\n","prev":{"title":"手动实现响应式布局","slug":"front-end-rlsd"},"next":{"title":"Numpy基础操作","slug":"numpy-Numpy基础操作"},"link":"http://lilpig.site/post/ml-KNN/","reward":true,"copyright":{"author":"LIL PIG","link":"<a href=\"http://lilpig.site/post/ml-KNN/\" title=\"KNN算法\">http://lilpig.site/post/ml-KNN/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}