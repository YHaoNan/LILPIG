{"title":"JS里的继承","date":"2019-05-21T07:58:27.000Z","slug":"js-extends","tags":["js"],"categories":["js"],"updated":"2019-05-29T09:00:37.498Z","content":"<p>JS中动态语言和prototype的特性让它可以用很多方法实现继承。</p>\n<h3 id=\"原型链\">原型链<a href=\"post/js-extends#原型链\"></a></h3><p>我们之前说过原型，可以理解为模板哈。那么想想OOP中的继承，其实不就是继承模板吗，于是大佬们想到了这样继承：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//猴子</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Monkey</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Monkey.prototype.jump = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'JUMP!!'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Monkey.prototype.run = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'RUN!!'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//人</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//继承 实际上就是初始化一个Monkey对象作为自己的原型</span></span><br><span class=\"line\">Person.prototype = <span class=\"keyword\">new</span> Monkey();</span><br><span class=\"line\">Person.prototype.speak = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Blah Blah Blah...'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">person.run();</span><br><span class=\"line\">person.speak();</span><br></pre></td></tr></table></figure></p>\n<p>当调用person.run时，会在person中找该属性，然后并没有找到，就去prototype中找，它的prototype是个Monkey对象，在Monkey中也没有直接的定义，于是就去Monkey对象的<code>[[ProtoType]]</code>中找，一层一层的，所以最后能找到run。</p>\n<p>所以Object的<code>toString</code>在每个对象中都能访问也是这样的原理。</p>\n<p>说道继承就得说重写，这重写应该不难了，就直接在person的Prototype中写或者在Person构造函数中直接定义。</p>\n<p>不过有些问题，如果我在父类的函数中定义一些属性，就没法通过原型链的方式继承了。比如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Monkey</span>(<span class=\"params\">height,weight</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.height = height;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.weight = weight;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这里如果想继承父类的height和weight就很难了。构造函数没法传值，没法让用户创建对象时传入。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">Person.prototype = <span class=\"keyword\">new</span> Monkey();</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>这下就看出问题了。不过这里我们有一个解决办法，我们可以在子类构造器中调用父类的构造器。这下不用原则链就可以实现继承。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Monkey</span>(<span class=\"params\">height,weight</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.height = height;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.weight = weight;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">height,weight</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//调用父类构造函数初始化，传入this，做完这一步会把父类的构造函数中创建的所有属性继承过来</span></span><br><span class=\"line\">    Monkey.call(<span class=\"keyword\">this</span>,height,weight);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//继承父类的原型，做完这部会把父类的原型继承过来</span></span><br><span class=\"line\">Person.prototype = <span class=\"keyword\">new</span> Monkey();</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>一般情况下，我们为了保证引用类型不被修改的问题在构造器中初始化一些属性，为了提高公共方法复用性在原型中初始化一些方法。</p>\n<h3 id=\"原型式继承\">原型式继承<a href=\"post/js-extends#原型式继承\"></a></h3><p>原型式继承提供一个函数，基于一个传入的对象作为原型创建另一个对象，这和很多语言中的<code>clone</code>差不多。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">object</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>同样要注意对于引用类型修改值的问题。</p>\n<p>ECMAScript5中新增了<code>Object.create()</code>方法，其实和上面方法做的差不多。不过她有两个参数，第二个参数是一个对象，第二个对象中有的所有属性都会覆盖第一个参数。</p>\n<p>如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> personCopy = <span class=\"built_in\">Object</span>.create(person,&#123;</span><br><span class=\"line\">    name:<span class=\"string\">'Bot'</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>personCopy拥有person的所有属性，但是name会被替换。</p>\n","prev":{"title":"JS创建对象的几种方法","slug":"js-object"},"next":{"title":"Leetcode - Add Two Number","slug":"leetcode-addtwo"},"link":"http://lilpig.site/post/js-extends/","reward":true,"copyright":{"author":"LIL PIG","link":"<a href=\"http://lilpig.site/post/js-extends/\" title=\"JS里的继承\">http://lilpig.site/post/js-extends/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}