{"title":"Nodejs中的异步编程 -- Promise","date":"2019-07-25T06:33:46.000Z","slug":"nodejs-promise","tags":["async","nodejs"],"categories":["NodeJS"],"updated":"2019-07-25T07:00:37.427Z","content":"<p>Promise是一个用于链式编写异步代码的规范。嘶。我感觉没有<code>async</code>好使，不过可能各有各的好处吧！VSCode API整个都使用了Promise规范。</p>\n<p>Promise从语义上看就是一个承诺，承诺有两种状态，一个是兑现了(resolve 解决)、一个是没有兑现(reject 拒绝)，Promise通过这两种状态控制异步操作。</p>\n<p>一个链式操作大概是这样的：<br><code>task1().then(task2).then(task3).catch(err=&gt;{处理错误})</code></p>\n<p>其中每一个task都是一个方法，这个方法返回一个Proimse，方法中如果处理完成调用<code>resolve</code>，然后<code>then</code>也就是下一个任务函数被调用，如果处理出错调用<code>reject</code>，整个链条中断，<code>catch</code>被调用。</p>\n<p>比如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getFile</span>(<span class=\"params\">path</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve,reject</span>)</span>&#123;</span><br><span class=\"line\">        fs.readFile(path,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,data</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(err)</span><br><span class=\"line\">                reject(err);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                resolve(data);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">getFile(<span class=\"string\">'./file1'</span>).then(<span class=\"function\"><span class=\"params\">data</span>=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'file1 =&gt; \\n'</span>+data);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getFile(<span class=\"string\">'./file2.js'</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">data</span>=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'file2 =&gt; \\n'</span>+data);</span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"params\">err</span>=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'get an err =&gt; '</span>+err)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>上面代码提供了一个公共方法<code>getFile</code>返回promise对象，下面就可以通过<code>then-catch</code>进行链式调用了。它们是同步执行的。</p>\n<p>除了<code>catch</code>还可以接<code>finally</code>，不管结果怎样都会被执行。</p>\n<p>异步执行的话，可以使用<code>Promise.all</code>方法，这是一个静态方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.all([promise1,promise2,promise3]).then(<span class=\"function\"><span class=\"params\">data</span>=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125;).catch(err)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有任何一个promise返回了reject，都会回调<code>catch</code>，如果全部执行成功，<code>then</code>会被执行，并且所有的任务的结果会被封装成数组传递进去。</p>\n","prev":{"title":"（二）数据可见性以及共享对象 —— Java多线程学习","slug":"thread4j-c3-obj-share"},"next":{"title":"Nodejs中的异步编程 -- Async模块","slug":"nodejs-aysnc"},"link":"http://lilpig.site/post/nodejs-promise/","reward":true,"copyright":{"author":"LIL PIG","link":"<a href=\"http://lilpig.site/post/nodejs-promise/\" title=\"Nodejs中的异步编程 -- Promise\">http://lilpig.site/post/nodejs-promise/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}