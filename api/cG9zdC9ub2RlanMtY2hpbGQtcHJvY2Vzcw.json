{"title":"子进程以及通信-NodeJS","date":"2019-07-17T01:07:46.000Z","slug":"nodejs-child-process","tags":["nodejs"],"categories":["NodeJS"],"updated":"2019-07-25T02:44:45.109Z","content":"<p>NodeJS能保证高效的IO操作，但是在处理CPU密集型的任务时它的表现并不尽如人意，所以当处理这种任务时，我们尽量不要让Node处理，而是丢给其他的进程，然后再用Node与它通信。</p>\n<h2 id=\"执行外部命令\">执行外部命令<a href=\"post/nodejs-child-process#执行外部命令\"></a></h2><p>NodeJS对子线程的操作使用<code>child_process</code>模块。</p>\n<p>我们可以这样调用外部命令：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> exec = <span class=\"built_in\">require</span>(<span class=\"string\">'child_process'</span>).exec;</span><br><span class=\"line\"><span class=\"comment\">//执行外部命令</span></span><br><span class=\"line\">exec(<span class=\"string\">'dir'</span>,(err,stdout,stderr)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(err.message);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(stdout);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><code>exec</code>方法的第一个参数是命令的字符串，第二个参数是命令执行的回调，当系统执行你这个命令时，如果出现错误，则err肯定存在，我们可以通过判断err是否存在而确定命令是否执行成功。</p>\n<p><code>stdout</code>则是命令执行的基本输出，<code>stderr</code>则是命令执行的基本异常输出。</p>\n<p>如果你在中文环境下，你会发现上面示例的结果出现了乱码，这是因为编码不统一，windows的中文环境编码是gbk，我们可以通过为exec指定一个<code>options</code>参数来指定编码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exec(<span class=\"string\">'dir'</span>,&#123;<span class=\"attr\">encoding</span>:<span class=\"string\">'binary'</span>&#125;,(err,stdout,stderr)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(err.message);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(iconv.decode(<span class=\"keyword\">new</span> Buffer(stdout,<span class=\"string\">'binary'</span>),<span class=\"string\">'cp936'</span>)); </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在上面，我们把编码设置成了<code>binary</code>，这是原始的二进制编码，因为node本身不支持gbk，所以我们只能先让它返回二进制编码，然后通过<code>iconv</code>编码库转换成<code>cp936</code>，这下就是GBK编码了。</p>\n<p>options还允许为子进程设置环境变量，比如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//utils.convertToGBK即调用iconv库转换成cp936的过程</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Windows</span></span><br><span class=\"line\">exec(<span class=\"string\">'echo %CUS_VAR%'</span>,&#123;<span class=\"attr\">env</span>:&#123;<span class=\"attr\">CUS_VAR</span>:<span class=\"string\">'Hello,World!'</span>&#125;,<span class=\"attr\">encoding</span>:<span class=\"string\">'binary'</span>&#125;,(err,stdout,stderr)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(utils.convertToGBK(stdout));</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Linux</span></span><br><span class=\"line\">exec(<span class=\"string\">'echo $CUS_VAR'</span>,&#123;<span class=\"attr\">env</span>:&#123;<span class=\"attr\">CUS_VAR</span>:<span class=\"string\">'Hello,World!'</span>&#125;,<span class=\"attr\">encoding</span>:<span class=\"string\">'binary'</span>&#125;,(err,stdout,stderr)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(utils.convertToGBK(stdout));</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>还可以设置当前工作目录，即命令会在指定目录下执行：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exec(<span class=\"string\">'dir'</span>,&#123;<span class=\"attr\">cwd</span>:<span class=\"string\">'D:\\\\source'</span>,<span class=\"attr\">encoding</span>:<span class=\"string\">'binary'</span>&#125;,(err,stdout,stderr)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(utils.convertToGBK(stdout));</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用spawn与子进程交互\">使用spawn与子进程交互<a href=\"post/nodejs-child-process#使用spawn与子进程交互\"></a></h2><p>exec可以执行一个系统命令，但是我们并无法与它进行交互，因为使用exec你必须等待命令执行完毕才会返回给你执行的结果，如果我们想与之交互，那么就需要使用<code>spawn</code>方法了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> spawn = child_process.spawn;</span><br><span class=\"line\"><span class=\"keyword\">var</span> child2 = spawn(<span class=\"string\">'node'</span>,[<span class=\"string\">'m_child_2.js'</span>]);</span><br><span class=\"line\">child2.stdout.on(<span class=\"string\">'data'</span>,(data)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data.toString());</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//以下是m_child_2.js的内容</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">5</span>;i++)&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">_i</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(_i)</span><br><span class=\"line\">    &#125;(i),<span class=\"number\">1000</span>*i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行上面的代码，每隔一秒会输出一个数字。</p>\n<p><code>spawn</code>方法返回一个进程对象，这个进程对象有三个关键属性，分别是<code>stdout</code>、<code>stderr</code>和<code>stdin</code>，前两个是可读流，最后一个是可写流(用于向子进程输入)。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//向子线程写入数据</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> child3 = spawn(<span class=\"string\">'node'</span>,[<span class=\"string\">'m_child_3.js'</span>]);</span><br><span class=\"line\">child3.stdout.on(<span class=\"string\">'data'</span>,(data)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data.toString());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> interVal;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'开始随机生成数据，按Ctrl+C退出'</span>);</span><br><span class=\"line\">interVal = setInterval(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">    child3.stdin.write((<span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random()*<span class=\"number\">10</span>))+<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">&#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"comment\">//十秒钟后结束子进程</span></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>child3.kill(),<span class=\"number\">10000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">child3.on(<span class=\"string\">'exit'</span>,(code)=&gt;&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'child3退出,code=&gt;'</span>+code);clearInterval(interVal);&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//以下是m_child_3.js的内容</span></span><br><span class=\"line\">process.stdin.resume();</span><br><span class=\"line\">process.stdin.on(<span class=\"string\">'data'</span>,(data)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> n = <span class=\"built_in\">parseInt</span>(data.toString(),<span class=\"number\">10</span>);</span><br><span class=\"line\">        process.stdout.write(n+<span class=\"string\">','</span>+(n+<span class=\"number\">1</span>)+<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(err)&#123;</span><br><span class=\"line\">        process.stderr.write(err.message+<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在上面的示例中，我们让主进程随机生成一个10以内的整数，通过<code>stdin</code>发送给子进程，然后子进程会把他加一并输出到<code>stdout</code>中，这样主进程就会接收到它的输出。</p>\n<p>子进程引用了<code>process</code>对象，这是node提供的对象，代表当前进程。</p>\n<p>子进程结束时会发送<code>exit</code>事件，可以监听它做一些释放资源的操作，比如上面的代码就调用<code>clearInterval</code>。</p>\n","prev":{"title":"生命游戏教程","slug":"other-gameoflife"},"next":{"title":"NodeJS中的网络操作","slug":"nodejs-nodetcp"},"link":"http://lilpig.site/post/nodejs-child-process/","toc":[{"title":"执行外部命令","id":"执行外部命令","index":"1"},{"title":"使用spawn与子进程交互","id":"使用spawn与子进程交互","index":"2"}],"reward":true,"copyright":{"author":"LIL PIG","link":"<a href=\"http://lilpig.site/post/nodejs-child-process/\" title=\"子进程以及通信-NodeJS\">http://lilpig.site/post/nodejs-child-process/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}