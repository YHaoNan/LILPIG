{"title":"JS创建对象的几种方法","date":"2019-05-21T07:58:27.000Z","slug":"js-object","tags":["js"],"categories":["js"],"updated":"2019-05-21T08:58:19.740Z","content":"<h3 id=\"对象字面量\">对象字面量<a href=\"post/js-object#对象字面量\"></a></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Person = &#123;</span><br><span class=\"line\">    name:<span class=\"string\">\"Pikachu\"</span>,</span><br><span class=\"line\">    age:<span class=\"number\">16</span>,</span><br><span class=\"line\">    sayHello:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello,I'm \"</span>+<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上创建了一个Person对象，他叫Pikachu，但是如果我还想再创建一个Person对象，就得重新写，没有一个用于创建对象的模板，熟悉OOP的应该已经意识到了，就是没有<code>类</code>这种东西(事实上js确实没有)。这样会产生很多重复代码。</p>\n<h3 id=\"工厂模式\">工厂模式<a href=\"post/js-object#工厂模式\"></a></h3><p>如果你对设计模式有所了解，工厂模式你肯定不陌生。可以使用工厂模式创建一个Object的实例并且扩展它的属性后返回。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createPerson</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">    o.name = name;</span><br><span class=\"line\">    o.age = age;</span><br><span class=\"line\">    o.sayHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello,I'm \"</span>+<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = createPerson(<span class=\"string\">'Pikachu'</span>,<span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = createPerson(<span class=\"string\">'Peppa Pig'</span>,<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure></p>\n<p>这样你就有了一个用于创建对象的模板，可以直接调用该工厂方法创建对象。</p>\n<p>不过工厂模式有问题，就是创建出的对象没有明确的类型，就是Object类型的。而且对于<code>sayHello</code>这种方法，每个对象都可以共用，但是使用工厂模式每次创建一个对象就会生成一个新的<code>sayHello</code>。</p>\n<h3 id=\"构造函数模式\">构造函数模式<a href=\"post/js-object#构造函数模式\"></a></h3><p>刚刚工厂模式中用到了这样一行：<code>var obj = new Object();</code>，这就是用到了Object类的构造函数来创建Object对象。</p>\n<p>如何定义一个构造函数？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello,I'm \"</span>+<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Pikachu'</span>,<span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Peppa Pig'</span>,<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure></p>\n<p>这样就可以创建对象了，并且创建出的对象的类型明确指定为<code>Person</code>。当你使用new关键字时，Person函数会被当做构造函数使用，并且返回一个创建好的对象。而当你不用new时，它就会被当做普通函数使用，这时其中的this指向引用时的作用域。</p>\n<p>不过这个<code>sayName</code>方法复用的问题好像还没解决。</p>\n<p>不过我们知道，函数也是一个对象，我们从全局创建一个函数，然后放到Person中，不就实现了复用吗？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayName</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello,I'm \"</span>+<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sayName = sayName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不过问题是解决了，但是在全局中声明这个函数好像有点怪怪的，而且可读性也不高，很容易让人不理解。</p>\n<h3 id=\"原型模式\">原型模式<a href=\"post/js-object#原型模式\"></a></h3><p>原型模式解决了这个问题，所为原型，你可以看做一个对象的模板，我们每创建一个函数都有<code>prototype</code>属性，它指向一个对象，当我们用这个函数初始化对象的时候，这个对象中的<code>[[Prototype]]</code>属性指向这个函数的<code>prototype</code>指向的对象。这时就做到了模板的功能。</p>\n<p>PS:这不是纯原型模式，而是原型和构造函数混合使用，纯原型模式有问题，基本不会用，所以不说。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>)</span>&#123;&#125;</span><br><span class=\"line\">Person.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello,I'm \"</span>+<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Pikachu'</span>,<span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Peppa Pig'</span>,<span class=\"number\">13</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.assert(person1.sayName == person2.sayName);</span><br></pre></td></tr></table></figure>\n<p>此时person1和person2共用一个sayName。</p>\n<p>有一点要说明的是，javascript访问一个对象的属性或者是方法时会经过如下步骤(忽略继承)：  </p>\n<ol>\n<li>在自身的属性中找</li>\n<li>如果步骤一没找到，在<code>[[Prototype]]</code>指向的对象中找</li>\n</ol>\n<p>所以如上代码中的断言成立不是因为person1和person2的sayName属性相同(虽然可以看做相同)，它们根本没有这两个属性，它俩访问到的sayName都是prototype中定义的。</p>\n<p>所以，当执行如下代码时：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello,I'm \"</span>+<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Pikachu'</span>,<span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Peppa Pig'</span>,<span class=\"number\">13</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">person1.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'PikaPika~~'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">person1.sayName();<span class=\"comment\">//PikaPika~~</span></span><br><span class=\"line\">person2.sayName();<span class=\"comment\">//Hello,I'm Peppa Pig</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.assert(person1.sayName == person2.sayName);<span class=\"comment\">//失败的断言</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>修改person1的sayName时并不会影响到person2，而是在person1中加入了一个新的<code>sayName</code>属性，而不用原型中的了。而person2中依旧没有sayName，所以还会使用原型中的。</p>\n<p>考虑一个问题，我们既然用了原型，就是因为希望多个对象共享属性模板，我们肯定不希望模板中的内容被修改吧。目前来看原型无论如何都不会被修改，不过如果原型中存了一个引用类型可就不一定了。</p>\n<p>比如说：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.friends = [<span class=\"string\">'Robot'</span>]</span><br></pre></td></tr></table></figure></p>\n<p>给原型中加入一个朋友属性，是一个数组，数组是引用类型，我们虽然无法通过对象对原型中的默认属性进行修改，但是对于引用类型，只要它提供了方法，我们仍然可以直接修改它。</p>\n<p>比如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Pikachu'</span>,<span class=\"number\">12</span>);</span><br><span class=\"line\">person1.friends.push(<span class=\"string\">'Robot2'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Peppa Pig'</span>,<span class=\"number\">13</span>);</span><br><span class=\"line\">person2.friends; <span class=\"comment\">//Robot,Robot2</span></span><br></pre></td></tr></table></figure></p>\n<p>我们调用了person1.friends的push方法，这时我们并没有对friends属性用<code>=</code>号直接赋值，而是调用了push方法添加了一个值，这时就会对其他对象造成影响。所以对于引用类型尽量不要使用原型。(这也就是开头说的不用纯原型模式的原因)。</p>\n<h3 id=\"直接重写原型\">直接重写原型<a href=\"post/js-object#直接重写原型\"></a></h3><p>每次添加一个属性都需要写冗长的代码，其实我们还可以重新重写原型。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    xxx:xxx,</span><br><span class=\"line\">    xxx:xxx,</span><br><span class=\"line\">    xxx:xxx</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>不过我们思考下，这么做是直接把原型给替换了，那么原型中本来存在的东西就会消失。每个原型中其实本身有一个<code>constructor</code>属性，指向对应的方法。比如<code>Person.prototype.constructor</code>指向<code>Person</code>。使用这个就可以确定类型了，<code>instanceof</code>关键字就是根据这个来判定的。所以当你直接重新写了这个原型的话，那么就无法通过<code>instanceof</code>去判断它的类型了。</p>\n<p>比如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Pikachu'</span>,<span class=\"number\">15</span>);</span><br><span class=\"line\">p1 <span class=\"keyword\">instanceof</span> Person <span class=\"comment\">//true</span></span><br><span class=\"line\">p1 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span> <span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype = &#123;</span><br><span class=\"line\">    xxx:xxx,</span><br><span class=\"line\">    xxx:xxx,</span><br><span class=\"line\">    xxx:xxx</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">p1 <span class=\"keyword\">instanceof</span> Person <span class=\"comment\">//false</span></span><br><span class=\"line\">p1 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span> <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n","prev":{"title":"JS里的继承","slug":"js-extends"},"next":{"title":"Leetcode - Add Two Number","slug":"lc-addtwo"},"link":"http://yoursite.com/post/js-object/","reward":true,"copyright":{"author":"LIL PIG","link":"<a href=\"http://yoursite.com/post/js-object/\" title=\"JS创建对象的几种方法\">http://yoursite.com/post/js-object/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}