{"title":"贪心算法","date":"2020-02-02T10:58:19.000Z","slug":"algorithm-greedy-alg","tags":["算法","贪心算法"],"categories":["算法"],"updated":"2020-02-03T03:25:12.005Z","content":"<p>上一节说了动态规划，我们知道了动态规划常用来寻找最优解。动态规划考虑了每个子问题，这通常会产生平方级别的时间复杂度还有因为要保存最优解造成的额外空间复杂度。但是有的时候我们并不需要考虑所有子问题，所以可以避免那些不必要的开销。</p>\n<h2 id=\"贪心算法\">贪心算法<a href=\"post/algorithm-greedy-alg#贪心算法\"></a></h2><p>贪心算法是一种只需考虑每一步的局部最优解以达到全局最优解的算法。</p>\n<p>我们先看具体题目。</p>\n<h3 id=\"背包问题\">背包问题<a href=\"post/algorithm-greedy-alg#背包问题\"></a></h3><p>有n个物体,第i个重量为Wi,在总重量不超过C的情况下拿走更多的物品</p>\n<p>我们考虑这个问题，只需要将重量数组排序，按顺序拿，直到总重量大于C就可以了。</p>\n<p>我们可以用数学反证法来证明。如果对于物品{k1,k2,k3}的总重量小于C，而且所有物品里还有重量小于k3的，那么我们总可以把k3换成更小的那个，而不影响什么。并且还可能因为此次替换多装几件物品。</p>\n<p>所以，我们就可以编写代码了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solution</span><span class=\"params\">(M,A)</span>:</span></span><br><span class=\"line\">    M.sort()</span><br><span class=\"line\">    result = []</span><br><span class=\"line\">    S = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> M:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> S + i &lt;= A:</span><br><span class=\"line\">            S = S + i</span><br><span class=\"line\">            result.append(i)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n<h2 id=\"背包问题2\">背包问题2<a href=\"post/algorithm-greedy-alg#背包问题2\"></a></h2><p>有n个物体,第i个物体的重量为wi,价值为vi 在总重量不超过c的情况下,让总价值尽量高。返回总价值。</p>\n<p>这个问题多了个价格，因为我们要用尽量轻的重量拿走更高价格的东西。我们可以用价格重量之比来排序，先拿走比值大的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solution</span><span class=\"params\">(W,V,C)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">byThird</span><span class=\"params\">(elem)</span>:</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> elem[<span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\"># 使用价格重量比按从高到低排序</span></span><br><span class=\"line\">   VW = [(V[i],W[i],V[i]/W[i]) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(W))]</span><br><span class=\"line\">   VW.sort(key=byThird,reverse=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">   s = <span class=\"number\">0</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(VW)):</span><br><span class=\"line\">       <span class=\"keyword\">if</span> VW[i][<span class=\"number\">1</span>] &lt;= C:</span><br><span class=\"line\">           s = s + VW[<span class=\"number\">0</span>]</span><br><span class=\"line\">       <span class=\"keyword\">else</span>:</span><br><span class=\"line\">           <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n<h2 id=\"乘船问题\">乘船问题<a href=\"post/algorithm-greedy-alg#乘船问题\"></a></h2><p>有n个人,第i个人重量为wi,每艘船的最大载重均为C(假设每个人的体重都小于C),且最多只能乘两个人,用最少的船装所有人。输出船的数量。</p>\n<p>该问题可以将人按重量排序，然后用双指针法两面遍历。先上代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solution</span><span class=\"params\">(W,C)</span>:</span></span><br><span class=\"line\">    W.sort()</span><br><span class=\"line\">    i, j = <span class=\"number\">0</span>,len(W) - <span class=\"number\">1</span></span><br><span class=\"line\">    cost = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i&lt;j:</span><br><span class=\"line\">        j = j - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> W[i] + W[j] &lt;= C:</span><br><span class=\"line\">            i = i + <span class=\"number\">1</span></span><br><span class=\"line\">        cost = <span class=\"number\">1</span> + cost</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cost</span><br></pre></td></tr></table></figure></p>\n<p>我们看循环，<code>j=j-1</code>代表把队伍中右面的人扔到船上，然后判断最左边的人的体重加刚刚上船的人的体重加起来是否小于C，也就是船上能否再容纳这个左边的人了，如果可以，<code>i=i+1</code>代表把左边的人扔到船上，因为船是严格升序排序的，所以如果i所在位置的人加j所在位置的人的重量都无法上船，那后面的就更不可能了。所以什么都不做，让j自己上（体现在代码上就是没有else）。</p>\n<h3 id=\"区间问题\">区间问题<a href=\"post/algorithm-greedy-alg#区间问题\"></a></h3><p>数轴上有n个开区间(ai,bi)。尽量选择多个区间，使得这些区间两两没有公共点。</p>\n<p>考虑如下两个区间：<code>(2,8),(4,6)</code>，我们选择了第一个就不能选择第二个了，因为第一个和第二个有公共点。但如果你把他俩反过来你就会发现，<code>(4,6)</code>是一个更好的选择。万一有一个<code>(7,9)</code>的话，<code>(4,6)</code>可以让你比<code>(2,8)</code>多选一个。</p>\n<p>所以我们把所有区间按bi升序排序，选早结束的总比选晚结束的强。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solution</span><span class=\"params\">(R)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bySecond</span><span class=\"params\">(e)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> e[<span class=\"number\">1</span>]</span><br><span class=\"line\">    R.sort(key=bySecond)</span><br><span class=\"line\">    result = [R[<span class=\"number\">0</span>]]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> r <span class=\"keyword\">in</span> R[<span class=\"number\">1</span>:]:</span><br><span class=\"line\">        last = result[len(result) - <span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> r[<span class=\"number\">0</span>] &gt;= last[<span class=\"number\">1</span>]:</span><br><span class=\"line\">            result.append(r)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n<h3 id=\"区间选点\">区间选点<a href=\"post/algorithm-greedy-alg#区间选点\"></a></h3><p>数轴上有n个闭区间[ai,bi]。取尽量少的点，使得每个区间内都至少有一个点</p>\n<p>不同区间内含的点可以是同一个</p>\n<p>本问题和上一个基本相同，按bi排序后把bi作为要选的点。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solution</span><span class=\"params\">(R)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bySecond</span><span class=\"params\">(e)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> e[<span class=\"number\">1</span>]</span><br><span class=\"line\">    R.sort(key=bySecond)</span><br><span class=\"line\">    lastR = R[<span class=\"number\">0</span>]</span><br><span class=\"line\">    points = [R[<span class=\"number\">0</span>][<span class=\"number\">1</span>]]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> r <span class=\"keyword\">in</span> R[<span class=\"number\">1</span>:]:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> r[<span class=\"number\">0</span>] &gt; lastR[<span class=\"number\">1</span>]:</span><br><span class=\"line\">            points.append(r[<span class=\"number\">1</span>])</span><br><span class=\"line\">            lastR = r</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> points</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"突击战\">突击战<a href=\"post/algorithm-greedy-alg#突击战\"></a></h3><p>有n个部下，n个任务，每个部下需要独立完成一项任务。第i个部下需要你花费Bi分钟交代任务，然后他会立刻独立无间断之行完毕</p>\n<p>选择交代任务的顺序，使得所有任务尽早执行完毕。</p>\n<p>这让我想起了小时候我妈总是先把洗衣机定时45分钟，然后煮饭定时30分钟，这些都定完了，再看一会电视，等待工作完成。</p>\n<p>让时间长的任务先干起来，这很自然，顺理成章。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solution</span><span class=\"params\">(B,W)</span>:</span></span><br><span class=\"line\">    W.sort(reverse=<span class=\"literal\">True</span>)</span><br><span class=\"line\">    allB = <span class=\"number\">0</span> </span><br><span class=\"line\">    allTime = <span class=\"number\">0</span> </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(W)):</span><br><span class=\"line\">        allB = allB + B[i]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> allB + W[i] &gt; allTime:</span><br><span class=\"line\">            allTime = allTime + (allB + W[i] - allTime)</span><br><span class=\"line\">        print(allTime)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> allTime</span><br></pre></td></tr></table></figure>\n<h3 id=\"运酒\">运酒<a href=\"post/algorithm-greedy-alg#运酒\"></a></h3><p>直线上有n（2&lt;=n&lt;=100000）个等距离的村庄，每个村庄要么买酒，要么卖酒。第i个村庄对酒的需求是ai（-1000&lt;=ai&lt;=1000），其中，ai<0表示买酒，ai>0表示卖酒。所有ai之和为0。把k个单位的酒从一个村庄运到相邻村庄需要k个单位的劳动力。计算最少需要多少劳动力。</0表示买酒，ai></p>\n<p>因为是直线上的村庄，所以只能按顺序传递酒水。比如第一个村庄需要买10瓶，第二个村庄需要卖9瓶，那么第二个村庄总共还要向后面的村庄买1瓶，因为最后ai=0,所以不怕买不到或卖不出。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solution</span><span class=\"params\">(A)</span>:</span></span><br><span class=\"line\">    k = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(A) - <span class=\"number\">1</span>):</span><br><span class=\"line\">        k = k + abs(A[i])</span><br><span class=\"line\">        A[i+<span class=\"number\">1</span>] = A[i] + A[i+<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> k</span><br></pre></td></tr></table></figure>\n","next":{"title":"动态规划","slug":"algorithm-dp"},"link":"http://lilpig.site/post/algorithm-greedy-alg/","toc":[{"title":"贪心算法","id":"贪心算法","index":"1","children":[{"title":"背包问题","id":"背包问题","index":"1.1"}]},{"title":"背包问题2","id":"背包问题2","index":"2"},{"title":"乘船问题","id":"乘船问题","index":"3","children":[{"title":"区间问题","id":"区间问题","index":"3.1"},{"title":"区间选点","id":"区间选点","index":"3.2"},{"title":"突击战","id":"突击战","index":"3.3"},{"title":"运酒","id":"运酒","index":"3.4"}]}],"reward":true,"copyright":{"author":"LIL PIG","link":"<a href=\"http://lilpig.site/post/algorithm-greedy-alg/\" title=\"贪心算法\">http://lilpig.site/post/algorithm-greedy-alg/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}