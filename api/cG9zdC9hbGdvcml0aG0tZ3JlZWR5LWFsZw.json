{"title":"贪心算法","date":"2020-02-02T10:58:19.000Z","slug":"algorithm-greedy-alg","tags":["算法","贪心算法"],"categories":["算法"],"updated":"2020-02-02T11:46:25.806Z","content":"<p>上一节说了动态规划，我们知道了动态规划常用来寻找最优解。动态规划考虑了每个子问题，这通常会产生平方级别的时间复杂度还有因为要保存最优解造成的额外空间复杂度。但是有的时候我们并不需要考虑所有子问题，所以可以避免那些不必要的开销。</p>\n<h2 id=\"贪心算法\">贪心算法<a href=\"post/algorithm-greedy-alg#贪心算法\"></a></h2><p>贪心算法是一种只需考虑每一步的局部最优解以达到全局最优解的算法。</p>\n<p>我们先看具体题目。</p>\n<h3 id=\"背包问题\">背包问题<a href=\"post/algorithm-greedy-alg#背包问题\"></a></h3><p>有n个物体,第i个重量为Wi,在总重量不超过C的情况下拿走更多的物品</p>\n<p>我们考虑这个问题，只需要将重量数组排序，按顺序拿，直到总重量大于C就可以了。</p>\n<p>我们可以用数学反证法来证明。如果对于物品{k1,k2,k3}的总重量小于C，而且所有物品里还有重量小于k3的，那么我们总可以把k3换成更小的那个，而不影响什么。并且还可能因为此次替换多装几件物品。</p>\n<p>所以，我们就可以编写代码了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solution</span><span class=\"params\">(M,A)</span>:</span></span><br><span class=\"line\">    M.sort()</span><br><span class=\"line\">    result = []</span><br><span class=\"line\">    S = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> M:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> S + i &lt;= A:</span><br><span class=\"line\">            S = S + i</span><br><span class=\"line\">            result.append(i)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n<h2 id=\"背包问题2\">背包问题2<a href=\"post/algorithm-greedy-alg#背包问题2\"></a></h2><p>有n个物体,第i个物体的重量为wi,价值为vi 在总重量不超过c的情况下,让总价值尽量高。返回总价值。</p>\n<p>这个问题多了个价格，因为我们要用尽量轻的重量拿走更高价格的东西。我们可以用价格重量之比来排序，先拿走比值大的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solution</span><span class=\"params\">(W,V,C)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">byThird</span><span class=\"params\">(elem)</span>:</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> elem[<span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\"># 使用价格重量比按从高到低排序</span></span><br><span class=\"line\">   VW = [(V[i],W[i],V[i]/W[i]) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(W))]</span><br><span class=\"line\">   VW.sort(key=byThird,reverse=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">   s = <span class=\"number\">0</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(VW)):</span><br><span class=\"line\">       <span class=\"keyword\">if</span> VW[i][<span class=\"number\">1</span>] &lt;= C:</span><br><span class=\"line\">           s = s + VW[<span class=\"number\">0</span>]</span><br><span class=\"line\">       <span class=\"keyword\">else</span>:</span><br><span class=\"line\">           <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n<h2 id=\"乘船问题\">乘船问题<a href=\"post/algorithm-greedy-alg#乘船问题\"></a></h2><p>有n个人,第i个人重量为wi,每艘船的最大载重均为C(假设每个人的体重都小于C),且最多只能乘两个人,用最少的船装所有人。输出船的数量。</p>\n<p>该问题可以将人按重量排序，然后用双指针法两面遍历。先上代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">solution</span><span class=\"params\">(W,C)</span>:</span></span><br><span class=\"line\">    W.sort()</span><br><span class=\"line\">    i, j = <span class=\"number\">0</span>,len(W) - <span class=\"number\">1</span></span><br><span class=\"line\">    cost = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> i&lt;j:</span><br><span class=\"line\">        j = j - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> W[i] + W[j] &lt;= C:</span><br><span class=\"line\">            i = i + <span class=\"number\">1</span></span><br><span class=\"line\">        cost = <span class=\"number\">1</span> + cost</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cost</span><br></pre></td></tr></table></figure></p>\n<p>我们看循环，<code>j=j-1</code>代表把队伍中右面的人扔到船上，然后判断最左边的人的体重加刚刚上船的人的体重加起来是否小于C，也就是船上能否再容纳这个左边的人了，如果可以，<code>i=i+1</code>代表把左边的人扔到船上，因为船是严格升序排序的，所以如果i所在位置的人加j所在位置的人的重量都无法上船，那后面的就更不可能了。所以什么都不做，让j自己上（体现在代码上就是没有else）。</p>\n","next":{"title":"动态规划","slug":"algorithm-dp"},"link":"http://lilpig.site/post/algorithm-greedy-alg/","toc":[{"title":"贪心算法","id":"贪心算法","index":"1","children":[{"title":"背包问题","id":"背包问题","index":"1.1"}]},{"title":"背包问题2","id":"背包问题2","index":"2"},{"title":"乘船问题","id":"乘船问题","index":"3"}],"reward":true,"copyright":{"author":"LIL PIG","link":"<a href=\"http://lilpig.site/post/algorithm-greedy-alg/\" title=\"贪心算法\">http://lilpig.site/post/algorithm-greedy-alg/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}