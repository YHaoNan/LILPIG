{"title":"Nodejs中的异步编程 -- Async模块","date":"2019-07-25T02:44:09.000Z","slug":"nodejs-aysnc","tags":["async","nodejs"],"categories":["NodeJS"],"updated":"2019-07-25T06:33:34.601Z","content":"<p>Node是一个非阻塞IO的编程语言，既然是非阻塞就涉及到回调，因为只有通过回调模式才能接收到IO操作返回的东西，比如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.stat(<span class=\"string\">'xxx'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,stat</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(stat);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码就是通过一个回调函数来获取文件的状态，如果不用回调会发生什么？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> stat = fs.stat(<span class=\"string\">'xxx'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stat);</span><br></pre></td></tr></table></figure></p>\n<p>我们用返回值的方式接收状态消息，不过实际上<code>stat</code>并不会返回文件状态，我们假设它会。执行<code>fs.stat</code>时，因为IO操作是一个耗时操作，它在Node里被设计为非阻塞的，所以并不会等到<code>fs.stat</code>执行完就会执行<code>console.log</code>，<code>stat</code>的结果应该是<code>undefined</code>，因为给它赋值的时候<code>fs.stat</code>还没执行完。</p>\n<p>所以这就是为什么在非阻塞IO下要用回调来接收返回值，传统的赋值式返回值无法工作，这个问题就算没学过node，在很多编程语言里也有体现，就不多说了。</p>\n<p>那么回调有它的好处，自然也有坏处，坏处就是当我们需要以同步的方式执行这些逻辑的时候会发生这种情况：</p>\n<div class=\"article-img\"><p><img src=\"http://nsimg.cn-bj.ufileos.com/img-1564023283075.jpg\" alt=\"图片\" data-zoomable></p></div>\n<p>这样的代码不仅很丑而且很难维护，异常不好处理，内层的回调无法抽出来公共使用，这样就会增加很多冗余代码。这种情况被称作回调地狱（callback-hell)。</p>\n<p>比如我们有这样的代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">done</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(err)</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(err.message);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Ok'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">    fs.exists(<span class=\"string\">'./a.txt'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">isExists</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!isExists) <span class=\"keyword\">throw</span> <span class=\"string\">'Got an error...'</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'A is exists...'</span>)</span><br><span class=\"line\">        fs.open(<span class=\"string\">'./a.txt'</span>,<span class=\"string\">'r'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,fd</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(err) <span class=\"keyword\">throw</span> <span class=\"string\">'Got an error...'</span>;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'Open file a...'</span>);</span><br><span class=\"line\">            fs.exists(<span class=\"string\">'./b.txt'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">isExists1</span>)</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!isExists1) <span class=\"keyword\">throw</span> <span class=\"string\">'Got an error...'</span>;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'B is exists...'</span>);</span><br><span class=\"line\">                fs.open(<span class=\"string\">'./b.txt'</span>,<span class=\"string\">'w'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,fd1</span>)</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(err) <span class=\"keyword\">throw</span> <span class=\"string\">'Got an error...'</span></span><br><span class=\"line\">                    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Open file b...'</span>);</span><br><span class=\"line\">                    fs.createReadStream(<span class=\"string\">''</span>,&#123;<span class=\"attr\">fd</span>:fd&#125;).pipe(fs.createWriteStream(<span class=\"string\">''</span>,&#123;<span class=\"attr\">fd</span>:fd1&#125;))</span><br><span class=\"line\">                    done(<span class=\"literal\">null</span>);</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(err)&#123;</span><br><span class=\"line\">    done(err);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先它确实不是一个好代码，它首先判断<code>a.txt</code>是否存在，如果存在就打开，然后判断<code>b.txt</code>是不是存在，如果存在打开，之后把<code>a.txt</code>的内容复制给<code>b.txt</code>，过程中如果任何一个步骤出现了问题都会抛出异常，它们会被外层的<code>try-catch</code>代码块捕获，并传给最后的<code>done</code>方法，如果一切正常，则会调用<code>done(null)</code>。</p>\n<p>如上的链式操作让回调变得难以理解和维护，试想如果情况再复杂一点，我们复制给b后还要复制给c，并且过程中a可能会被删除，我们每个步骤都要判断a是否存在（这只是个假设）。那么会多很多重复的代码，并且回调的层级会更深。</p>\n<p>我们怎么解决它呢？我们可以通过这种方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">series</span>(<span class=\"params\">functions,finalCallback</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentFn=<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">next</span>(<span class=\"params\">err,args</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">            finalCallback(err,args);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(++currentFn &lt; functions.length)</span><br><span class=\"line\">            <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                functions[currentFn](next,args);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">catch</span>(err)&#123;</span><br><span class=\"line\">                finalCallback(err)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            finalCallback(err,args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    next();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports.series = series;</span><br></pre></td></tr></table></figure></p>\n<p>我们编写一个<code>series</code>方法，这个方法有两个参数，第一个是需要执行的所有方法，这些方法将按顺序执行，第二个参数是最终的回调，当发生错误时或全部执行完毕时回调。</p>\n<p><code>series</code>中提供一个<code>currentFn</code>记录当前执行的函数是第几个，然后就是一个next函数，执行下一个函数时需要调用<code>next</code>，<code>series</code>函数会把<code>next</code>的控制权交给函数列表里待执行的函数，每一个待执行的函数执行完毕后需要手动调用<code>next</code>，并且告知是否出现异常，并且可以传参。如果出现异常，<code>series</code>立刻执行函数列表的顺序执行，并调用<code>finalCallback</code>。</p>\n<p>每个函数在执行期间可能也会发出同步的错误，需要被<code>try-catch</code>捕获，捕获到的也会被移交给<code>finalCallback</code>。</p>\n<p>最后导出这个函数。</p>\n<p>然后可以通过这个方法改写我们之前的代码，让它更便于维护：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> async_controller = <span class=\"built_in\">require</span>(<span class=\"string\">'./async_controller'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">async_controller.series([</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">next</span>)</span>&#123;</span><br><span class=\"line\">        fs.exists(<span class=\"string\">'./a.txt'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">isExists</span>)</span>&#123;</span><br><span class=\"line\">            next(!isExists);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">next</span>)</span>&#123;</span><br><span class=\"line\">        fs.open(<span class=\"string\">'./a.txt'</span>,<span class=\"string\">'r'</span>,next);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">next,fd</span>)</span>&#123;</span><br><span class=\"line\">        fs.exists(<span class=\"string\">'./b.txt'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">isExists</span>)</span>&#123;</span><br><span class=\"line\">            next(!isExists,fd);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">next,fd</span>)</span>&#123;</span><br><span class=\"line\">        fs.open(<span class=\"string\">'./b.txt'</span>,<span class=\"string\">'w'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,fd1</span>)</span>&#123;</span><br><span class=\"line\">            next(err,[fd,fd1]);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">next,args</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(args)</span><br><span class=\"line\">        fs.createReadStream(<span class=\"string\">''</span>,&#123;<span class=\"attr\">fd</span>:args[<span class=\"number\">0</span>]&#125;).pipe(fs.createWriteStream(<span class=\"string\">''</span>,&#123;<span class=\"attr\">fd</span>:args[<span class=\"number\">1</span>]&#125;));</span><br><span class=\"line\">        next(<span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(err)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'get an err '</span>+ err);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Done...'</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>这样一来，函数列表中每个部分可以抽出来，并且美观了不少，语义上也更像同步执行的代码了。</p>\n<p>其实早就有这种异步库了，没有什么是npm里没有的，我们通过npm安装一下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install async --save</span><br></pre></td></tr></table></figure></p>\n<p>嘶，，npm赐我个女朋友吧！！！</p>\n<p>好了，我们来学习一下这个<code>async</code>库，先来看看它的几个关于流程控制的方法：</p>\n<h3 id=\"串行执行-series\">串行执行 <code>series</code><a href=\"post/nodejs-aysnc#串行执行-series\"></a></h3><p><code>series</code>函数用于将一串异步操作串行执行，和我们的差不多，不过它不能在函数之间传递参数，如果要传递参数，<code>async</code>里提供了另外的方法，它的使用方法如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">async</span> = <span class=\"built_in\">require</span>(<span class=\"string\">'async'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span>.series([</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">next</span>)</span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>next(<span class=\"literal\">null</span>,<span class=\"string\">'1'</span>),<span class=\"number\">100</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">next</span>)</span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>next(<span class=\"literal\">null</span>,<span class=\"string\">'2'</span>),<span class=\"number\">100</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">next</span>)</span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>next(<span class=\"literal\">null</span>,<span class=\"string\">'3'</span>),<span class=\"number\">100</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">next</span>)</span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>next(<span class=\"literal\">null</span>,<span class=\"string\">'4'</span>),<span class=\"number\">100</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">next</span>)</span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>next(<span class=\"literal\">null</span>,<span class=\"string\">'5'</span>),<span class=\"number\">100</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,result</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>没错，这和我们之前自己写的那个<code>series</code>差不多（这么说可能有点不要脸了），只不过它不能向下一个函数传递参数，它调用<code>next</code>传递的参数都会以列表的形式传递给最后一个回调（不是函数列表中的最后一个，而是<code>series</code>中的最后一个参数)。</p>\n<p>所以上面代码的结果是<code>[1,2,3,4,5]</code>。</p>\n<h3 id=\"并行执行-parallel\">并行执行 <code>parallel</code><a href=\"post/nodejs-aysnc#并行执行-parallel\"></a></h3><p>可能有人会问，妈蛋，我如果什么都不做不就直接是并行执行的吗？确实是，不过<code>async</code>库中的并行执行能让你更方便的管理每个方法的结果和异常。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">async</span> = <span class=\"built_in\">require</span>(<span class=\"string\">'async'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span>.parallel([</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">next</span>)</span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>next(<span class=\"literal\">null</span>,<span class=\"string\">'1'</span>),<span class=\"number\">100</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">next</span>)</span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>next(<span class=\"literal\">null</span>,<span class=\"string\">'2'</span>),<span class=\"number\">100</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">next</span>)</span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>next(<span class=\"literal\">null</span>,<span class=\"string\">'3'</span>),<span class=\"number\">100</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">next</span>)</span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>next(<span class=\"literal\">null</span>,<span class=\"string\">'4'</span>),<span class=\"number\">100</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">next</span>)</span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>next(<span class=\"literal\">null</span>,<span class=\"string\">'5'</span>),<span class=\"number\">100</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">next</span>)</span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>next(<span class=\"literal\">null</span>,<span class=\"string\">'6'</span>),<span class=\"number\">100</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,result</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>虽然是并行执行，但这个result也会按顺序返回。</p>\n<h3 id=\"限制并发-parallelLimit\">限制并发 <code>parallelLimit</code><a href=\"post/nodejs-aysnc#限制并发-parallelLimit\"></a></h3><p>在多线程开发中，线程池是个很重要的东西，它可以设置一个最大的线程数，如果没有线程池的限制，不停的创建线程会耗尽系统的资源。</p>\n<p>在nodejs的异步编程中这个限制也极其重要，如果不停的去并发跑任务，那么系统的资源也会被耗尽，<code>async</code>库的<code>parallelLimit</code>可以提供一个最大并发任务的限制。</p>\n<p><code>async.parallelLimit(tasks,10,callback)</code></p>\n<p>上面这行代码指定最大并行任务数是10。</p>\n<h3 id=\"瀑布流传参-waterfall\">瀑布流传参 <code>waterfall</code><a href=\"post/nodejs-aysnc#瀑布流传参-waterfall\"></a></h3><p>这个函数能够在函数列表中传参，函数串行执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">async</span> = <span class=\"built_in\">require</span>(<span class=\"string\">'async'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pow</span>(<span class=\"params\">num,next</span>)</span>&#123;setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>next(<span class=\"literal\">null</span>,num*<span class=\"number\">2</span>),<span class=\"number\">100</span>)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span>.waterfall([</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">next</span>)</span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>next(<span class=\"literal\">null</span>,<span class=\"number\">2</span>),<span class=\"number\">100</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    pow,pow,pow,pow</span><br><span class=\"line\">],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,result</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>上面的代码计算2的六次方。</p>\n<h3 id=\"自动-auto\">自动 <code>auto</code><a href=\"post/nodejs-aysnc#自动-auto\"></a></h3><p>相信你已经感受到async库的强大了，但是它还有更牛逼的奇淫技巧，就是自动完成同步异步的操作。</p>\n<p>想象我们有如下需求，我们需要从某个远程服务器A上获取数据，同时在远程服务器B上创建一个文件夹，当这两件事做完之后，我们向远程文件夹下写入从A那获取的数据，最后发送一个email提醒任务完成。</p>\n<p>这个操作用<code>waterfall</code>当然也可以，让它们全都是串行执行的，但是从A获取数据和通知B创建文件夹都是网络耗时任务，不如让它们并行执行，如果再用前面几个方法，就又会在最后一个回调处陷入回调地狱。</p>\n<p>auto可以解决这个问题，我们看下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">async</span> = <span class=\"built_in\">require</span>(<span class=\"string\">'async'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span>.auto(&#123;</span><br><span class=\"line\">    getData : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">next</span>)</span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>next(<span class=\"literal\">null</span>,<span class=\"string\">'&#123;DATA&#125;'</span>),<span class=\"number\">100</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    makeDir : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">next</span>)</span>&#123;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>next(<span class=\"literal\">null</span>,<span class=\"string\">'&#123;PATH&#125;'</span>),<span class=\"number\">200</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    writeData: [<span class=\"string\">'getData'</span>,<span class=\"string\">'makeDir'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg,next</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'write '</span>+arg[<span class=\"string\">'getData'</span>] + <span class=\"string\">' to '</span> + arg[<span class=\"string\">'makeDir'</span>]);</span><br><span class=\"line\">        next(<span class=\"literal\">null</span>,<span class=\"string\">'&#123;FILE&#125;'</span>);</span><br><span class=\"line\">    &#125;],</span><br><span class=\"line\">    sendEmail: [<span class=\"string\">'writeData'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg,next</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hey,'</span>+arg[<span class=\"string\">'writeData'</span>]+<span class=\"string\">' was created!'</span>);</span><br><span class=\"line\">        next(<span class=\"literal\">null</span>,<span class=\"string\">'Email'</span>);</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,arg</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(arg);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>上面的代码我们通过<code>auto</code>指定<code>writeData</code>和<code>sendEmail</code>的执行条件，只有当执行条件中的函数全部执行完毕，函数才能执行。没有指定的就并行执行。</p>\n<p>指定条件的函数可以有一个参数<code>arg</code>，这是一个字典，放置了所有执行完毕的函数的处理结果，所以如上代码的输出是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">write &#123;DATA&#125; to &#123;PATH&#125;</span><br><span class=\"line\">Hey,&#123;FILE&#125; was created!</span><br><span class=\"line\">&#123; getData: &apos;&#123;DATA&#125;&apos;,</span><br><span class=\"line\">  makeDir: &apos;&#123;PATH&#125;&apos;,</span><br><span class=\"line\">  writeData: &apos;&#123;FILE&#125;&apos;,</span><br><span class=\"line\">  sendEmail: &apos;Email&apos; &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"条件循环-whilist\">条件循环 <code>whilist</code><a href=\"post/nodejs-aysnc#条件循环-whilist\"></a></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">async</span> = <span class=\"built_in\">require</span>(<span class=\"string\">'async'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> counter = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> datas = [<span class=\"string\">'foo'</span>,<span class=\"string\">'bar'</span>,<span class=\"string\">'baz'</span>];</span><br><span class=\"line\"><span class=\"keyword\">async</span>.whilst(<span class=\"function\">(<span class=\"params\">cb</span>)=&gt;</span>cb(<span class=\"literal\">null</span>,counter&lt;datas.length),</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">cb</span>)</span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;<span class=\"built_in\">console</span>.log(datas[counter++]);cb(<span class=\"literal\">null</span>,counter)&#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err,n</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(err)</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'Got an error'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(n +<span class=\"string\">' passed!'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><code>whilst</code>第一个参数是一个测试函数，需要调用回调并传入一个条件。当条件满足会不断地执行第二个参数，当然是串行，当有错误发生或条件不满足则回调第三个。</p>\n<p>关于<code>async</code>中的流程控制还有很多方法，推荐去看<a href=\"http://caolan.github.io/async/v3/docs.html\" target=\"_blank\" rel=\"noopener\">async官方文档</a>。</p>\n<p>下面来说说<code>async</code>在其他方面的造诣。</p>\n<p><code>async</code>提供了一组函数用于操作集合，和大多函数式编程的语义差不多。</p>\n<h3 id=\"遍历-each\">遍历 <code>each</code><a href=\"post/nodejs-aysnc#遍历-each\"></a></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">async</span> = <span class=\"built_in\">require</span>(<span class=\"string\">'async'</span>);</span><br><span class=\"line\"><span class=\"keyword\">async</span>.each([<span class=\"string\">'task1'</span>,<span class=\"string\">'task2'</span>,<span class=\"string\">'task3'</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg,next</span>)</span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'Handling '</span>+arg+<span class=\"string\">' now ...'</span>);</span><br><span class=\"line\">        next(<span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(err) <span class=\"built_in\">console</span>.log(<span class=\"string\">'Got an err '</span>, err); </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><code>each</code>是并发的，第一个参数中的每一个元素将被传入第二个回调中，如果在回调中出现异常，请调用<code>next</code>并传入异常对象，<code>async</code>会立即调用最后一个回调。</p>\n<p>同样有一个<code>eachLimit</code>函数可以限制最大并行任务数。</p>\n<p>同样有一个<code>eachSeries</code>用来串行执行。</p>\n<h3 id=\"转换-map\">转换 <code>map</code><a href=\"post/nodejs-aysnc#转换-map\"></a></h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">async</span> = <span class=\"built_in\">require</span>(<span class=\"string\">'async'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">async</span>.map([<span class=\"string\">'a.txt'</span>,<span class=\"string\">'b.txt'</span>], fs.stat, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, results</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(results)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>将第一个参数中的元素挨个传入第二个回调，并且收集第二个回调的结果最终传给最后一个回调。</p>\n<p>同样有异步和限制版本。</p>\n<p><code>async</code>的功能实在是太多了，不一一例举了，想深入学习的去官方文档看吧。</p>\n<p><a href=\"http://caolan.github.io/async/v3/docs.html\" target=\"_blank\" rel=\"noopener\">async官方文档</a></p>\n","prev":{"title":"Nodejs中的异步编程 -- Promise","slug":"nodejs-promise"},"next":{"title":"（一）基本概念 —— Java多线程学习","slug":"thread4j-c2-basic"},"link":"http://lilpig.site/post/nodejs-aysnc/","reward":true,"copyright":{"author":"LIL PIG","link":"<a href=\"http://lilpig.site/post/nodejs-aysnc/\" title=\"Nodejs中的异步编程 -- Async模块\">http://lilpig.site/post/nodejs-aysnc/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)"}}